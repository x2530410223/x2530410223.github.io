{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"书单","date":"2021-07-12T08:00:46.376Z","updated":"2021-07-12T08:00:46.376Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-12T08:00:46.376Z","updated":"2021-07-12T08:00:46.376Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-12T08:00:46.375Z","updated":"2021-07-12T08:00:46.375Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2021-07-12T08:00:46.376Z","updated":"2021-07-12T08:00:46.376Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-07-12T08:00:46.373Z","updated":"2021-07-12T08:00:46.373Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-12T08:00:46.376Z","updated":"2021-07-12T08:00:46.376Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-12T08:00:46.377Z","updated":"2021-07-12T08:00:46.377Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"day08","slug":"day08","date":"2021-07-27T11:31:14.000Z","updated":"2021-07-27T11:32:43.940Z","comments":true,"path":"2021/07/27/day08/","link":"","permalink":"http://example.com/2021/07/27/day08/","excerpt":"","text":"static关键字 static修饰的成员是在JVM加载类的时候就会被立即分配空间以及初始化 - 只有1次,内存的实例只有1份 非静态的成员的是在每次创建对象的时候才会被分配空间以及初始化 作用 static修饰符类 - 静态内部类[过] 修饰的属性 - 静态属性 方法 - 静态方法 代码块 - 静态代码块 JVM加载类进内存的活动顺序 JVM加载类进内存 给所有的静态属性分配空间以及初始化 给所有的静态方法分配空间以及初始化 调用静态代码块 如果创建了对象 4-1. 给这个对象的所有的非静态属性分配空间以及初始化 4-2. 给这个对象的所有的非静态方法分配空间 4-3. 调用普通代码块 4-4. 调用构造块 static关键字应用 设计模式 - 单例模式 如何保证某个类的对象在内存中永远只有1份.后期,某些类的创建和销毁的时间成本比较高.这些类有必要设计成单例的. 比如jdbc中的连接池对象[重量级的对象] 饿汉模式 多线程安全12345678910111213141516171819202122232425262728293031package tech.aistar.design.singleton.version01;/** * 本类用来演示: 将Singleton01设置成饿汉模式 - 单例的 * * @author: success * @date: 2021/7/27 9:28 上午 */public class Singleton01 &#123; //2. 初始化一个变量,该变量就是该类的唯一实例[对象] private static Singleton01 instance = new Singleton01(); //1. 私有化构造 private Singleton01()&#123; //比较费时费力的代码,可能需要更多的时间 System.out.println(&quot;Singleton01...&quot;); &#125; //3. 提供一个公开的静态的方法来返回这个类的唯一实例 public static Singleton01 getInstance()&#123; return instance; &#125;&#125;class TestSingleton01&#123; public static void main(String[] args) &#123; //获取类的实例 Singleton01 s1 = Singleton01.getInstance(); Singleton01 s2 = Singleton01.getInstance(); System.out.println(s1 == s2);//true &#125;&#125; 懒汉模式 多线程不安全123456789101112131415161718192021222324252627package tech.aistar.design.singleton.version02;/** * 本类用来演示: 懒汉 * * @author: success * @date: 2021/7/27 9:35 上午 */public class Singleton02 &#123; private static Singleton02 instance; private Singleton02()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton02 getInstance()&#123; return instance == null?instance = new Singleton02():instance; &#125;&#125;class TestSingleton02&#123; public static void main(String[] args) &#123;// Singleton02 s1 = Singleton02.getInstance();// Singleton02 s2 = Singleton02.getInstance();// System.out.println(s1 == s2); &#125;&#125; 双重检查锁 - 笔试脱手写的版本 懒汉模式下 - 仍然是多线程安全的 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.design.singleton.version03;/** * 本类用来演示:双重检查锁 - 笔试脱手写的版本 * * @author: success * @date: 2021/7/27 10:07 上午 */public class Singleton03 &#123; private static Singleton03 instance; private Singleton03()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton03 getInstance()&#123; //因为本身&quot;锁&quot;资源就是一个比较昂贵的资源,为了避免跑得慢的线程去抢这个把锁,所以此处也要进行非空判断. if(instance == null)&#123; //跑得快的线程都会进入此处A,B //A,B线程就会去争抢锁资源,谁抢到锁资源,谁就会进入 //同步代码块去执行里面的代码 //假设A线程抢到了,B就会在等待 synchronized (Singleton03.class)&#123; //A进入判断instance==null //只要抢到&quot;锁&quot;的线程,如果此处没有非null判断 //那么进入到这的线程都会去执行instance = new Singleton03(); if(instance == null)&#123; //由A线程进行实例的初始化 //A继续执行,等A执行完毕之后,那么A就会释放锁资源 //其他线程继续争抢锁资源. instance = new Singleton03(); &#125; &#125; &#125; return instance; &#125;&#125; volatile 可见性 - 忽略 禁止JVM的指令重排 12345678910int i=10;//原子性操作Student s = new Student();//不是一个原子性操作①给s对象分配内存空间②调用构造块,执行构造函数 - 初始化动作③将引用s指向内存中的那个对象. 但是JVM内部会对这些指令进行一个优化操作.本来你的顺序应该是①-②-③,经过JVM指令重排之后,顺序有可能变成①-③-② 123456789101112131415161718192021222324252627282930313233343536373839package tech.aistar.design.singleton.version03;/** * 本类用来演示:双重检查锁 - 笔试脱手写的版本 * * @author: success * @date: 2021/7/27 10:07 上午 */public class Singleton03 &#123; private volatile static Singleton03 instance; //private static Singleton03 instance; private Singleton03()&#123; System.out.println(&quot;私有化构造&quot;); &#125; public static Singleton03 getInstance()&#123; //② - 跑得很慢的线程刚刚到达此处,其他线程判断instance是不为null的 //但是instance可能指向的是一个&quot;半成品&quot; - A线程还没有完成构造方法. //其他线程可能会使用到这个&quot;半成品&quot;对象,肯定会有问题. if(instance == null)&#123; synchronized (Singleton03.class)&#123; if(instance == null)&#123; //① - A线程可能执行到2步骤的时候,instance已经不为null //不是一个原子性操作,可能经过JVM指令重排 //1. 给instance对象分配空间 //2. 将对象的内存地址赋值给了instance //3. 调用构造方法 instance = new Singleton03(); &#125; &#125; &#125; return instance; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"static","slug":"static","permalink":"http://example.com/tags/static/"}]},{"title":"day07","slug":"day07","date":"2021-07-26T03:29:55.000Z","updated":"2021-07-26T03:31:39.811Z","comments":true,"path":"2021/07/26/day07/","link":"","permalink":"http://example.com/2021/07/26/day07/","excerpt":"","text":"抽象类 抽象类天生就是用来被子类继承的.抽象类天生就是不能够被外部进行实例化的 抽象类使用abstract关键字来进行修饰 抽象类中允许存在构造方法,普通属性,普通方法以及抽象方法. 普通类是没有资格去定义抽象方法 抽象方法也是使用abstract来修饰的,抽象方法是指没有方法体的方法. 抽象的方法天生也是用来被子类重写的. 抽象类是一种抽象的数据类型. 抽象类的继承的特点 如果某个普通的子类继承了抽象类,那么这个子类必须要重写这个抽象父类中的所有的抽象方法. 如果某个子类继承了抽象类,不想重写抽象父类中的所有的抽象方法,那么需要将这个子类也定义成抽象类. 不能一起混用的修饰符 final和abstract一起使用 private和abstract能不能一起修饰方法. static和abstract不能一起用来修饰方法 static是不存在多态的. 模板方法设计模式 模板方法模式很常用，其目的是在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。在标准的模板方法模式实现中，主要是使用继承的方式，来让父类在运行期间可以调用到子类的方法。即：处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。处理步骤在父类中定义好，具体实现延迟到子类中定义 。 抽象的类应用 - 模板方法设计模式. 模板类中只负责定义 需要做的事情 - 不需要具体的实现,具体的实现留给各个子类去实现. 做的事情的流程[步骤] 123456789101112131415161718192021222324package tech.aistar.design.template;/** * 本类用来演示: * * @author: success * @date: 2021/7/23 9:36 上午 */public abstract class TemplateDemo &#123; //规定了需要完成的事情 public abstract void start();//演员登台 public abstract void play();//演员表演 public abstract void end();//落幕 //提供一个不可变的方法,用来控制事情执行的顺序 public final void execute()&#123; this.start(); this.play(); this.end(); &#125;&#125; 缺点模板方法的优点和缺点： 优点： 模板方法提供了一个很好的代码复用平台。 实现了反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，符合 “开闭原则”。 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 接口 属于抽象的数据类型,也是不能够被实例化的 接口中不允许定义普通属性的,不允许出现构造的. jdk8.x允许在接口中使用default关键字来定义普通方法. 接口也是用来定义抽象的方法的.接口中的方法都是抽象的方法. 接口的属性都是公开的静态的常量属性. 定义接口的关键字是interface,编译之后也是.class字节码文件 接口也是可以静态方法的. 命名规则 使用I开头或者able结尾 多态的另外应用 面向接口编程 对象的编译时类型写成接口,对象的运行时类型写成是实现类 方法的参数类型写成接口,调用方法时可以传入这个接口的任意一个实现类. 方法的返回类型写成接口,方法的返回结果的类型可以是这个接口的任意一个实现类. 接口的规则 接口和类 - 类是可以去实现这个接口的. 接口天生是用来是实现类来实现的 - implements 普通的类去实现某个接口的话,那么必须要实现这个接口中所有的抽象方法 如果抽象的类去实现某个接口的话,那么可以选择实现或者不实现. 一个接口可以拥有多个实现类. 一个类可以同时实现多个接口,接口之间用逗号隔开.需要实现这些接口中所有的抽象方法. 接口和接口 一个接口可以继承多个接口,接口是支持多重继承的. 应用 提供了一种”契约机制”,屏蔽了底层的具体的实现,为了程序的拓展 作用 - 制定开发的这个软件中的功能 - “业务方法” 接口的分类 业务接口 - 该接口中只定义抽象方法 常量接口 - 该接口中只定义了常量属性,管理系统中所有的常量属性的.jdk5.x使用了枚举类型来替代了常量接口 标记接口 - 什么都没有,做标记的. 123456public interface IA&#123;&#125;public class Aimpl implements IA&#123;...&#125;Aimpl a = new Aimpl();System.out.println(a instanceof IA);//true 函数式接口 - jdk8.x - 配合jdk8.x - lambda表达式 里面只有一个抽象方法的接口 - @FunctionalInterface 设计模式概述设计模式概念设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 七大原则为什么要提倡“Design Pattern”呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？面开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。 单一职责原则简介:单一职责原则（Single Responsiblity Principle SRP） 接口或类只提供一种业务实现。 单一职责原则宗旨是每个接口、类的功能，只能用来做专门的事，强调系统内业务职责唯一，避免职责扩散，做到业务统一管理. 开闭原则简介:总原则:开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代 码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 里氏替换原则简介:里氏替换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实 现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 因为继承带来的侵入性，增加了耦合性，也降低了代码灵活性，父类修改代码，子类也会受到影响，此时就需要里氏替换原则。 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。 子类中可以增加自己特有的方法。 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 依赖倒转原则简介:依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 接口隔离原则简介:接口隔离原则（Interface Segregation Principle） 这个原则的意思是：每个接口中不存在实现类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 迪米特法则简介:迪米特法则（最少知道原则）（Demeter Principle) 就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装方法的内部，通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部 变量出现在类中。 合成复用原则简介:合成复用原则（Composite Reuse Principle) 原则是尽量首先使用合成/聚合的方式，而不是使用继承。 简单工厂模式简单工厂模式是属于创建型模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。 作用:把对象的创建和对象的使用分离 User user = new User();//对象的创建和对象使用没有分离 普通简单工厂 - 必须要脱手写出来的.1234567891011121314151617181920212223242526272829303132333435//1. 根据传入的参数来返回某个具体的产品[对象]package tech.aistar.design.factory.simple01;/** * 本类用来演示: 简单工厂 * * @author: success * @date: 2021/7/23 3:19 下午 */public class ProductFactory &#123; public static final int QQ = 1; public static final int WX = 2; //根据传入的参数来返回某个具体的产品 //多态的应用 - 面向接口编程 //3. 方法的返回类型写成接口,方法的执行结果可以是这个接口的任意一个实现类. public static Sender getInstance(int type)&#123; Sender sender = null; switch (type)&#123; case 1: //对象的创建 - 复杂的过程... sender = new QQSender(); break; case 2: sender = new WXSender(); break; default: System.out.println(&quot;参数不合法&quot;); break; &#125; return sender; &#125;&#125; 多方法简单工厂1234567891011121314151617181920package tech.aistar.design.factory.simple02;/** * 本类用来演示: 多方法工厂 * * @author: success * @date: 2021/7/23 3:32 下午 */public class ProductFactory &#123; //有几个产品,就定义几个方法 //每个方法负责生成一个产品 public Sender createQQ()&#123; return new QQSender(); &#125; public Sender createWx()&#123; return new WXSender(); &#125;&#125; 静态方法简单工厂1234567891011121314151617181920package tech.aistar.design.factory.simple02;/** * 本类用来演示: 多方法工厂 * * @author: success * @date: 2021/7/23 3:32 下午 */public class ProductFactory &#123; //有几个产品,就定义几个方法 //每个方法负责生成一个产品 public static Sender createQQ()&#123; return new QQSender(); &#125; public static Sender createWx()&#123; return new WXSender(); &#125;&#125; 简单工厂优缺点优点： 很明显，简单工厂的特点就是“简单粗暴”，通过一个含参的工厂方法，我们可以实例化任何产品类，上至飞机火箭，下至土豆面条，无所不能。所以简单工厂有一个别名：上帝类。 缺点： 任何”东西“的子类都可以被生产，负担太重。当所要生产产品种类非常多时，工厂方法的代码量可能会很庞大 在遵循开闭原则（对拓展开放，对修改关闭）的条件下，简单工厂对于增加新的产品，无能为力。因为增加新产品只能通过修改工厂方法来实现。 工厂方法模式简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能， 直接增加新的工厂类就可以了，不需要修改之前的代码。 工厂方法模式优缺点优点： 工厂方法模式就很好的减轻了工厂类的负担，把某一类/某一种东西交由一个工厂生产；（对应简单工厂的缺点1） 同时增加某一类”东西“并不需要修改工厂类，只需要添加生产这类”东西“的工厂即可，使得工厂类符合开闭原则。 缺点： 相比简单工厂，实现略复杂。 对于某些可以形成产品族的情况处理比较复杂（相对抽象工厂）。 抽象工厂模式抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个*产品族*中的产品对象。根据里氏替换原则，任何接受父类型的地方，都应当能够接受子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例。 抽象工厂模式优缺点优点： 抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建。 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点： 增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类。 作业 循环 OO题 123456789101112131415161718192021222324Book[id,name,price...] 1.定义图书操作业务接口 IBookBiz有如下方法://添加图书 void add(Book b);//根据图书name 来删除指定图书 void deleteByName(String name);//打印出所有的图书信息 void outputAllBooks();2. 定义 数组图书管理业务实现类(ArrayBookBiz) 实现 IBookBiz接口，实现所有方法,提示，给出如下属性属性:private static final int CAPACITY = 5;private int count; //代表有效图书数量private Book[] books = new Book[CAPACITY];方法： 就是实现接口中的所有方法最后，写测试类，测试这三个方法. 接口练习题 12345678910111213141516171819202122232425接口更重要的作用：作为模块与模块之间一个协议，软件生产一直希望能够像硬件生产一样：主板可由一个厂家生产，显卡可由另一个厂家生产，用户只需要将显卡插到主板上的显卡插槽上，便可以协同工作了。（插槽——主板、显卡的标准接口已经确定，插槽就是接口）。显卡厂商去实现接口中所暴露出来的方法。主板只需要利用显卡的插槽去获取（调用）显卡的功能。1、 定义一个显卡接口VideoCard，此接口中有抽象方法： 1） videoRunning()：显示显卡运行信息 ; 2） videoClosing()：显示显卡停止工作时的信息;2、 定义一个芯片接口Cpu,此接口中有抽象方法： 1） cpuRunning()：显示显卡运行信息 ; 2） cpuClosing()：显示显卡停止工作时的信息;3、 定义类IntelCpu：实现Cpu接口的全部功能，其中包括： 1） 无参构造方法：显示：” Make an Intel&#x27;s CPU”. 2） 实现Cpu接口的所有方法4、 定义类DmengVideoCard：实现VideoCard接口的全部功能，其中包括： 1） 无参构造方法：显示：”Make a Dmeng&#x27;s VideoCard”. 2） 实现VideoCard接口的所有方法.5、 定义类Mainboard 1） 创建有参构造体，传入显卡和芯片 2） run():显示主板运行信息 3） close():显示主板停止信息6、 定义一个Computer类，包含主函数main(),组装一台电脑，测试接口的应用，其中main()方法包括： 1） 买一块Dmeng公司的显卡 2） 买一块Intel公司的芯片 3） 买一块主板:插上显卡、芯片 4） 组装好后，开机运行显示显卡、芯片、主板等开机信息。 5） 关机信息显示 6） 创建openPC方法，打开电脑。 7） 创建closePC方法，关闭电脑。 预习题 - static关键字 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142151. public class Cygnus&#123; static int value = 9; private void printValue()&#123; int value = 69; System.out.println(this.value); &#125; public static void main(String[] args) throws Exception&#123; new Cygnus().printValue(); &#125; &#125;这个程序会有下面哪种结果？A. 编译错误B. 打印9C. 打印69D. 运行时抛出异常---------------------------------------------------------------------------------------2. 写出以下程序的输出结果class Base&#123; static&#123; System.out.println(&quot;base static&quot;); &#125; public Base()&#123; System.out.println(&quot;base constructor&quot;); &#125;&#125;public class Test extends Base&#123; static&#123; System.out.println(&quot;test static&quot;); &#125; public Test()&#123; super(); System.out.println(&quot;test constructor&quot;); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; ---------------------------------------------------------------------------------------3. 写出以下程序的输出结果public class Test &#123; static&#123; System.out.println(&quot;test static 1&quot;); &#125; public static void main(String[] args) &#123; &#125; static&#123; System.out.println(&quot;test static 2&quot;); &#125;&#125; ---------------------------------------------------------------------------------------4. public class test&#123; static&#123; int x=5; &#125; static int x,y; public static void main(String args[])&#123; x--; myMethod( ); System.out.println(x+y+ ++x); &#125; public static void myMethod( )&#123; y=x++ + ++x; &#125;&#125;A. 编译错误B. 输出：1C. 输出：2D. 输出：3E. 输出：7F. 输出：8 ---------------------------------------------------------------------------------------5. 阅读下列程序，选择哪一个是正确的输出结果 class HelloA&#123; public HelloA() &#123; System.out.println(&quot;I’m A class &quot;); &#125; static&#123; System.out.println(&quot;static A&quot;); &#125;&#125;public class HelloB extends HelloA&#123; public HelloB()&#123; System.out.println(&quot;I’m B class&quot;); &#125; static&#123; System.out.println(&quot;static B&quot;); &#125; public static void main (String[] args)&#123; new HelloB(); &#125;&#125;A. static A I’m A class static B I’m B classB. I’m A class I’m B class static A static BC. static A static B I’m A class I’m B classD. I’m A class static A I’m B class static B ---------------------------------------------------------------------------------------6. 以下代码的输出结果是？public class B&#123; public static B t1 = new B(); public static B t2 = new B(); &#123; System.out.println(&quot;构造块&quot;); &#125; static&#123; System.out.println(&quot;静态块&quot;); &#125; public static void main(String[] args)&#123; B t = new B(); &#125;&#125;A. 静态块 构造块 构造块 构造块B. 构造块 静态块 构造块 构造块C. 构造块 构造块 静态块 构造块D. 构造块 构造块 构造块 静态块 ---------------------------------------------------------------------------------------7. 下面代码在main方法代码后可以正常使用的是（ ）public class Test&#123; private int a=10; int b=20; static int c=1; public static void main(String arg[])&#123; Test t = new Test(); &#125; &#125;A. t.aB. this.cC. Test.bD. Test.c ---------------------------------------------------------------------------------------8. 下列程序执行后结果为( )class A &#123; public int func1(int a, int b) &#123; return a - b; &#125;&#125;class B extends A &#123; public int func1(int a, int b) &#123; return a + b; &#125;&#125;public class ChildClass &#123; public static void main(String[] args) &#123; A a = new B(); B b = new B(); System.out.println(&quot;Result=&quot; + a.func1(100, 50)); System.out.println(&quot;Result=&quot; + b.func1(100, 50)); &#125;&#125;A. Result=150Result=150B. Result=100Result=100C. Result=100Result=150D. Result=150Result=100 ---------------------------------------------------------------------------------------9. 以下代码执行后输出结果为（ ）public class Test&#123; public static Test t1 = new Test(); &#123; System.out.println(&quot;blockA&quot;); &#125; static&#123; System.out.println(&quot;blockB&quot;); &#125; public static void main(String[] args)&#123; Test t2 = new Test(); &#125; &#125;A. blockAblockBblockAB. blockAblockAblockBC. blockBblockBblockAD. blockBblockAblockB","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"Object","slug":"Object","permalink":"http://example.com/tags/Object/"}]},{"title":"day06","slug":"day06","date":"2021-07-26T03:26:49.000Z","updated":"2021-07-26T03:28:49.698Z","comments":true,"path":"2021/07/26/day06/","link":"","permalink":"http://example.com/2021/07/26/day06/","excerpt":"","text":"OO练习业务类和实体类合二为一 居然将业务方法放在了实体类中 - 违背了设计原则 - “单一职责原则”.不要给一个类增加太多的负担 实体类 - 主要是描述对象,数据在内存中的载体 - 注重的应该是数据的存储 业务类 - 存放的是业务方法 - 在于操作这些数据 员工类[编号id,姓名name,工资salary] 业务方法[crud增删改查]放在实体类中 - 不合理的. 1234567891011121314151617181920212223242526272829303132333435public class Emp&#123; private int id; private String name; private double salary; //一个上司拥有多个下属 //一个下属对应一个上司 //自关联 private Emp[] emps; //构造,getter/setter,toString //给上司添加一个下属 public void addEmp(Emp e)&#123; //数组的扩容Arrays.copyOf(数组对象,新的长度); &#125; //输出下属的个数 public void printEmpCount()&#123; &#125; //输出某个上司所有的下属信息 public void printEmp()&#123; &#125;&#125;//TestEmp.javaEmp boss = new Emp(1,&quot;boss&quot;,100.0,new Emp[0]);Emp e1 = new Emp(1,&quot;boss&quot;,100.0,null); 业务类和实体类分开 业务方法应该专门抽取出来放到一个业务类中. 12345678910111213141516public class Account&#123; private int id; private double balance;//余额 //...&#125;public class AccountBiz&#123; //转钱 public void test01(Account acc1,Account acc2,double money)&#123; &#125; //存钱&#125; 继承Inheritance 将多个具有共同特点的对象抽象出一个”父类”. 父类中存储的是各个子类共同的特点[属性]或者功能[方法] 继承的好处 - 提高了代码的复用性.使用多态的前提,为了代码的可拓展性. 继承的缺点 - 增加了类与类之间的关系.不太符合软件的设计原则”高内聚,低耦合” 低耦合 - 模块与模块之间/类与类之间的关系应该越弱越好 - 没有关系 高内聚 - 单个模块/类能够独立完成某个业务功能的能力比较强. 实际开发中,可以采用设计原则**”合成复用原则”** - 来替代继承的使用. 使用extends关键字来表示某个类继承某个父类 比如: 1234567891011121314public class A&#123; &#125;public class B extends A&#123; &#125;B 是 A的子类,A是B的父类,基类,超类.1. A的父类就是java.lang.Object - 当某个类如果没有明确指定它的父类是谁,那么这个类默认继承Object2. 子类是可以访问到父类中所有的非私有的成员3. java的类只支持单继承.一个类只能继承一个父类.避免出现网状结构,保证类的层次性. java中的接口是支持多重继承.一个接口可以继承多个接口.4. 继承具有传播性.C extends B B extends A C间接继承于A,C也是可以访问到A中的所有的非私有的成员5. 不要滥用继承,前提B is A super关键字 必须放在构造方法的首行 调用父类的构造 在子类的构造中,如果没有出现任何的super语句.那么系统默认会给定super(); - 调用父类的空参构造 当在子类中调用了一个和父类中同名的成员的时候,需要通过super关键字来加以区分[强制调用父类中那个同名的成员] 多态 - polymorphism 对象有多种形态.发生前提是具有继承关系 相同的消息可能会送给多个不同的类别之对象， 而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。简单来说，所谓多态意指相同的消息给予不同的对象会引发不同的动作。 instanceof 进行类型的判断,只有为true的时候,才能够进行类型的转换[强制,向下] 如果没有进行类型的判断,随便进行了一个强制类型转换,可能会抛出java.lang.ClassCastException类型转换失败异常 三种场景应用 面向父类编程 对象的编译时类型写成父类,对象的运行时类型写成子类 编译时类型 对象名 = new 运行时类型(); 对象的编译时类型决定了对象的访问能力 - “对象名只能访问到编译时类型中定义的成员” 对象的运行时类型决定了对象的行为能力 - “子类中如果一旦重写了父类中的方法,那么运行期间调用的是子类重写之后的方法” 方法的参数类型写成父类,调用这个方法的时候,可以传入这个父类的任意一个子类对象 方法的返回类型写成父类,方法的返回结果可以是这个父类的任意一个子类对象 - “简单工厂设计模式” final关键字 不可更改,不可变 final修饰的变量/属性 - 不能够重新赋值 final修饰的类 - 不能够被继承 final修饰的方法不能够被重写. 修饰符 访问修饰符 - 决定了这个成员可以在哪里能够被访问. 所有包 子类[可以不同,同包] 同包 本类 public 公共的,公开的 √ √ √ √ protected 受保护的 × √ √ √ 默认的 × × √ √ private 私有的 × × × √ 安全级别:private&gt;默认的&gt;protected&gt;public 可见区域:public&gt;protected&gt;默认的&gt;private 方法的重写 方法的重载和方法的重写有什么区别? 特点: 发生的前提是要有继承关系 重写有个特殊的场景 - 子类重写之后的方法的修饰符,返回类型,方法名,参数列表和父类中高度保持一致 - 重构 子类重写的方法的访问修饰符可以小于或者等于父类 方法名必须要一样. 子类重写的方法的返回类型可以小于[可以是父类方法的返回类型的子类类型]或者等于父类的那个方法 参数列表必须要高度保持一致 作业1234567891011121314151617181920212223242526272829303132333435361.设计一个形状类Shape,方法:求周长和求面积 形状类的子类:Rect(矩形),Circle(圆形) Rect类的子类:Square(正方形) 不同的子类会有不同的计算周长和面积的方法 创建三个不同的形状对象 分别打印出每个对象的周长和面积 [girth() area() -&gt; 放在父类] [每个子类需要重写这些方法!] - 不要想太多应用场景,语法!2.某公司的雇员分为以下若干类：Employee：这是所有员工总的父类，属性：员工的姓名,员工的生日Date。方法：getSalary(int month) 根据参数月份来确定工资，如果该月员工过生日，则公司会额外奖励100元。SalariedEmployee：Employee的子类，拿固定工资的员工。属性：月薪HourlyEmployee：Employee的子类，按小时拿工资的员工，属性：每小时的工资、每月工作的小时数每月工作超出160小时的部分按照1.5倍工资发放。SalesEmployee：Employee的子类，销售人员，工资由月销售额和提成率决定。属性：月销售额、提成率BasedPlusSalesEmployee：SalesEmployee的子类，有固定底薪的销售人员，工资由底薪加上销售提成部分。属性：底薪。写一个函数，打印出某月每个员工的工资数额。注意：要求把每个类都做成完全封装，不允许非私有化属性。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"Object","slug":"Object","permalink":"http://example.com/tags/Object/"}]},{"title":"day05","slug":"day05","date":"2021-07-21T12:51:00.000Z","updated":"2021-07-21T12:51:52.039Z","comments":true,"path":"2021/07/21/day05/","link":"","permalink":"http://example.com/2021/07/21/day05/","excerpt":"","text":"Date api:java.util.Date[C] - 使用这个类之前,必须要导包import 这是java中提供的关于日期的处理,内置的对象类型.它本身是一个过时的类 里面提供了很多已经过时的方法. 目标:掌握这个类中提供的方法 api手册构造方法 作用:创建这个类的对象的方式 观察提供的方法是静态的方法还是非静态的方法. - api手册方法摘要 Date类中提供的方法几乎都是非静态的方法 - 考虑如何构建这个对象? 如何构建对象 - api手册的构造方法[面向对象] 简单理解构造方法 - “方法”,构造方法通过new关键字调用 Date();//Date d = new Date();//获取当前系统时间 Date(int year, int month, int date);//已经过时的 123Date d2 = new Date(2021-1900,6,21);year - 1900 =&gt; 实际的yearmonth的范围是[0,11] Date(long date);//根据一个毫秒数来构建一个指定的日期类型 - 重新设置一个新的Date Java中日期类型Date对象是不支持运算的. 1234计算三天之后的此时此刻long afterThreeTime = new Date().getTime()+3L*24*60*60*1000;Date afterThreeDate = new Date(afterThreeTime);System.out.println(afterThreeDate); 常用方法 非静态方法 - 日期对象进行调用. long getTime();//返回当前日期的毫秒数的表现形式 - 获取当前系统时间的毫秒数.距离1970年1月1日 1970年是计算机的元年 get/set方法 - 过时的 void setYear(int year);// year-1900 void setMonth(int month);//month的范围[0,11] void setDate(int date);//设置今天是几号 void setHours(int hours);//设置小时 void setMinutes(int minutes);//设置分钟 void setSeconds(int seconds);//设置秒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package tech.aistar.day05;import java.util.Date;/** * 本类用来演示: java.util.Date 日期处理类 * * @author: success * @date: 2021/7/21 8:43 上午 */public class DateDemo &#123; public static void main(String[] args) &#123; //1. 创建一个日期对象 //alter + enter 快速导包 Date d = new Date();//空参构造方法 //为什么此处输出的不是内存地址??? - OO - toString(); //Wed Jul 21 08:45:03 CST 2021 System.out.println(d); //2. 重载的构造方法 - 过时的构造 Date d2 = new Date(2021-1900,6,21); System.out.println(d2); //3. 利用毫秒数来构建一个Date对象 Date d3 = new Date(1626829161216L); System.out.println(d3); System.out.println(&quot;====常用方法===&quot;); //4.. 获取当前日期的毫秒数 //1秒 = 1000毫秒 long nowTime = d.getTime(); System.out.println(nowTime);//1626828910303 //练习-计算三天之后的此时此刻 long afterThreeTime = new Date().getTime()+3L*24*60*60*1000; Date afterThreeDate = new Date(afterThreeTime); System.out.println(afterThreeDate); System.out.println(&quot;=====set设置/get获取======&quot;); Date now = new Date(); now.setYear(2021-1900);//设置年份 now.setMonth(6);//设置月份[0,11] now.setDate(25); System.out.println(&quot;now:&quot;+now); int year = now.getYear()+1900;//获取年份 System.out.println(&quot;year:&quot;+year); System.out.println(&quot;month:&quot;+now.getMonth());//获取月份 System.out.println(&quot;date:&quot;+now.getDate());//获取几号 System.out.println(&quot;day:&quot;+now.getDay()); // 周几,周1-周6[1-6],周日是0 System.out.println(&quot;hours:&quot;+now.getHours()); //void setTime(long date); //构造 Date(long time); Date dd = new Date(); dd.setTime(1726830007794L); System.out.println(dd); &#125;&#125; Calendar 日历类 - 超纲的内容 api - java.util.Calendar 1234public abstract class Calendarabstract[修饰符]修饰的类是一个抽象类 - 不能够被new构建Calendar对象 - Calendar cal = new Calendar();//error api手册常用方法 static Calendar getInstance(); 12//获取当前系统的日历对象Calendar cal = Calendar.getInstance();//底层使用到了简单工厂的设计模式[不需要了解暂时] 关于设置日历字段 12345678void set(int year, int month, int date)设置日历字段中的值 YEAR ， MONTH和 DAY_OF_MONTH 。 void set(int year, int month, int date, int hourOfDay, int minute)设置日历字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY和 MINUTE 。 void set(int year, int month, int date, int hourOfDay, int minute, int second)设置字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY ， MINUTE和 SECOND 。 12Date -&gt; Calendar void setTime(Date date); 单独针对单个字段一一进行赋值 12345void set(int field,int value);只要看到field//公开的静态的常量属性public static final int YEAR = 1; 关于获取日历字段 123Date getTime();//获取日历信息中关于日期部分的信息 - Calendar转成Date类型 int get(int field);//关于获取日历指定字段的值 总结 毫秒数 -&gt; Date 12a. java.util.Date中提供了构造方法Date(long time);b. 上述类void setTime(long time); Date -&gt; 毫秒数 1该类中long getTime(); Calendar -&gt; Date 1Calendar类中提供了Date getTime(); Date -&gt; Calendar 1Calendar类中void setTime(Date date); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package tech.aistar.day05;import java.util.Calendar;import java.util.Date;/** * 本类用来演示: 日历类java.util.Calendar * * @author: success * @date: 2021/7/21 9:30 上午 */public class CalendarDemo &#123; public static void main(String[] args) &#123; //超纲 - abstract是修饰符 - 修饰类 - 抽象的类 //特点 - 不能够被new[不能够被实例化,具体化] //Calendar cal = new Calendar();//error Calendar cal = Calendar.getInstance(); //System.out.println(cal); //统一设置值 cal.set(2020,6,21); //Calendar -&gt; Date Date now = cal.getTime(); System.out.println(now); //Date -&gt; Calendar Date d = new Date(17818237347L); cal.setTime(d); System.out.println(cal.get(1)); System.out.println(&quot;====单个字段一一赋值====&quot;); //void set(int field,int value); Calendar cd = Calendar.getInstance(); //通过字面量直接进行设置 - 可读性比较差 //获取Calendar中提供的一些公开的静态的常量属性 //System.out.println(); //常量的好处 - 提供程序的可读性 cd.set(Calendar.YEAR,2021); cd.set(Calendar.MONTH,6); cd.set(Calendar.DAY_OF_MONTH,24); System.out.println(cd.getTime());//Calendar-&gt;Date int year = cd.get(Calendar.YEAR); int month = cd.get(Calendar.MONTH)+1; int day = cd.get(Calendar.DAY_OF_MONTH); System.out.println(&quot;year:&quot;+year); System.out.println(&quot;month:&quot;+month); System.out.println(&quot;day:&quot;+day); //获取周几 int week = cd.get(Calendar.DAY_OF_WEEK); System.out.println(&quot;week:&quot;+week);//周日~周六,[1~7] &#125;&#125; 获取键盘键盘输入 java.util.Scanner键盘类 如何构建这个Scanner对象 1Scanner sc = new Scanner(System.in); 方法 3-1. int nextInt();//只能获取整数 3-2. double nextDouble();//获取小数 3-3. String nextLine();//获取字符串 注意点:nextLine不要和nextInt或者nextDouble混用. 面向对象 java语言属于面向对象的语言 面向对象本身不是一门具体的技术,符合人类思维的思想. 宗旨:把一个复杂的大型的业务,利用面向对象的思想进行面向对象的分析, 接着面向对象的设计,最终进行面向对象的编程. 对象是数据在内存中的”载体” 重新认识类和对象 类是抽象的概念,对象是具体的概念 类是构建对象的蓝图/模板,对象是类的具体的实例化[表现] 类是用来描述对象的. 比如: 类:水果 交通工具 学生 对象:榴莲 飞机 小三 比如: id username age 100 admin 18 101 tom 17 面向对象的思想 核心:”一切皆对象” ①分析出系统中业务的关键对象 - “找对象” - 未来页面上显示的数据 ②找出对象的**”属性”** - “对象拥有什么” ③分析出对象的”方法” - “对象可以干什么,对象的功能” ④找出对象与对象之间的关系. 12345671:1 - 一个丈夫对应一个妻子,一个妻子对应一个丈夫. 1:N - 一个客户拥有多个订单.一个订单只能属于一个客户 - 70%N:N - 一个学生可以选择多门课程,一门课程可以被多个学生来选择. 自关联 - 自己关联自己. ⑤最后一步才会去考虑具体怎么编码实现.可能也会考虑数据结构或者算法. “相亲业务” - 媒婆帮你找一个”对象” 你要查看”对象”的属性 询问”对象”的功能 分析你和”对象”是否来道🌩 考虑 - 追 - 彩礼 - 结婚 - 具体怎么实现! 面向过程的思想 C是典型的面向过程的思想 ①优先考虑的就是算法和数据结构 - 考虑的就是具体怎么实现. 实体类 实体类就是用来描述对象的. 实体类中包含属性,构造方法,getter/setter方法,toString方法. 如何定义属性 语法: 修饰符 数据类型 属性名 [=初始值]; 修饰符 public 公开的 private 私有的 数据类型 八种基本数据类型 内置对象类型以及自定义对象类型. 属性名 参考变量的命名 - “小驼峰” 三大特征 - 封装性 封装 - Encapsulation - 屏蔽底层的细节,数据提供保护的机制 属性私有化 提供getter/setter方法 setter方法 - set属性名[首字母变大写] - 推荐的命名规则 setter方法这种设置值的好处 2-1. setter方法中是可以进行参数有效性判断的. 2-2. 业务需求改变了 - 属性名称改变了,使用到这个属性的具体的地方都要发生改变 - “可维护性” 2-3. 并不是所有的属性的值都是通过那么太简单的计算得到的. 123456789101112131415161718192021222324public class Orders&#123; private int id; private double price; private int count; private double total; //getter/setter - 提供好了 public double getTotal()&#123; double result = this.price * this.count; return result; &#125; &#125;Orders o = new Orders();o.setPrice(100.0);o.setCount(10);//o.setTotal(o.getPrice()*o.getCount());System.out.println(o.getTotal()); 2-4. 并不是所有的属性都需要对外进行公开的. this关键字 作用1 - 当前对象,区分方法中参数和实体类中的定义的属性 - 当两者同名的时候. toString方法 当我们直接输出对象的时候,默认一定会去调用toString方法 - 如果这个对象是null,那么不会调用toString方法的 当自定义的实体类中没有手动提供toString方法,那么这个对象会自动去调用java.lang.Object类中的toString方法 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; java.lang.Object - 它是所有的类的根类,基类,超类,父类. 如果某个类没有明确指定它的父类,那么这个类默认会直接继承java.lang.Object类 “User类是Object类的儿子” - 规定 - “子类可以调用父类中所有的公开的成员“ Object类中提供的toString方法只能用来返回对象的内存地址 - 不满足实际的打印需求 所以需要在实体类中重新重写这个toString方法. 当子类User类一旦重写了toString方法之后,那么就会采取”就近原则”,直接调用自己重写 之后的toString方法.","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"base","slug":"base","permalink":"http://example.com/tags/base/"}]},{"title":"day04","slug":"day04","date":"2021-07-21T12:39:33.000Z","updated":"2021-07-21T12:48:40.620Z","comments":true,"path":"2021/07/21/day04/","link":"","permalink":"http://example.com/2021/07/21/day04/","excerpt":"","text":"递归算法 方法体中调用方法自己本身 递归算法的方法体中一定要出现递归的出口,否则会抛出java.lang.StackOverflowError - 堆栈溢出错误 使用场景:适合解决大量的,重复性的业务题 缺点:性能比较低,将每次计算的结果都会保存在内存中. 案例 求某个数的阶乘 ※ 12345678910111213141516/** * n! * @param n * @return */public static int jie(int n)&#123; //如果没有出口 - java.lang.StackOverflowError 堆栈溢出错误 //1. 第一个位置都是1 if(n==1) return 1; //2. 方法体中调用自己 return n*jie(n-1); // 6*jie(5) // 6*5*4*3*2*1&#125; 斐波那契数列 ※ 12345678910//斐波那契数列//1 1 2 3 5 8 13 21 34 55 ...public static int fei(int n)&#123; if(n == 1 || n==2) return 1; return fei(n-1) + fei(n-2); //n=4 //fei(3)+fei(2) //fei(2) + fei(1) + fei(2)=3&#125; 求最大公约数 123456//求最大公约数public static int commonDivisor(int m,int n)&#123; if(m % n ==0) return n; return commonDivisor(n,m%n);&#125; 求杨辉三角某行某列的值 1234567891011121314151617 /** * 1 * 1 1 * 1 2 1 * 1 3 3 1 * 1 4 6 4 1 * 1 5 10 10 5 1 * * @param x 纵坐标 行 * @param y 横坐标 列 * @return */public static int yang(int x,int y)&#123; if(y==0 || x==y) return 1; return yang(x-1,y-1) + yang(x-1,y);&#125; 打印直角三角形杨辉三角 123456789101112/** * 打印直角三角形. * @param x 打印的杨辉三角的行数 */public static void printYang(int x)&#123; for (int i = 0; i &lt; x; i++) &#123; for (int j = 0; j &lt;=i ; j++) &#123; System.out.print(yang(i,j)+&quot;\\t&quot;); &#125; System.out.println(); &#125;&#125; 二维数组 数据类型 变量 = 初始化; 数据类型 - 八种基本数据类型以及对象类型 数组本身就是属于对象类型 1int[] arr = new int[3];//arr的数据类型int[],整数型数组,int型数组 元素类型[] 变量名 = new 元素类型[数组长度]; ```int[][] 变量名 = new int[rows][cols]元素类型决定了数组中可以存放的数据的类型二维数组中的每个元素就是一维数组 1236. 定义一个3行2列的int型二维数组 int[][] arr = new int[3][2];int arr[][] = new int[3][2]; 12345## 赋值方式1. 通过下标一一赋值 int[][] arr = new int[3][2];arr[0][0]=100; 1234562. 定义二维数组的同时进行赋值 ```java int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;; int[][] arr2 = new int[][]&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;; 先定义一个数组,然后是一行一行赋值 123int[][] arr = new int[3][3];arr[0] = &#123;1,2,3&#125;;//errorarr[0] = new int[]&#123;1,2,3&#125;;//ok 定义一个不规则的二维数组 12345列可以省略不写int[][] arr4 = new int[3][];arr4[0] = new int[]&#123;1&#125;;arr4[1] = new int[]&#123;1,2&#125;;arr4[2] = new int[]&#123;1,3,1&#125;; 遍历方式 通过下标一一输出 通过单层for循环 123for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(Arrays.toString(arr[i]));&#125; 双层for循环 1234567for (int i = 0; i &lt; arr.length; i++) &#123; //int[] temp = arr[i]; for (int j = 0; j &lt; arr[i].length; j++) &#123; System.out.print(arr[i][j]+&quot;\\t&quot;); &#125; System.out.println();&#125; java.util.Arrays工具类中 1System.out.println(Arrays.deepToString(arr)); 增强for循环 12345678910for(元素类型 变量:数组对象名)&#123; &#125; for (int[] ints : arr) &#123; // System.out.println(ints); for (int r : ints) &#123; System.out.print(r+&quot;\\t&quot;); &#125; System.out.println(); &#125; 练习题123456789101112131415161718192021222324252627282930313233343536373839404142434445String[][] arr = new String[4][6];arr[0]=new String[]&#123;&quot;白&quot;,&quot;日&quot;,&quot;依&quot;,&quot;山&quot;,&quot;尽&quot;,&quot;,&quot;&#125;;arr[1]=new String[]&#123;&quot;黄&quot;,&quot;河&quot;,&quot;入&quot;,&quot;海&quot;,&quot;流&quot;,&quot;.&quot;&#125;;arr[2]=new String[]&#123;&quot;欲&quot;,&quot;穷&quot;,&quot;千&quot;,&quot;里&quot;,&quot;目&quot;,&quot;,&quot;&#125;;arr[3]=new String[]&#123;&quot;更&quot;,&quot;上&quot;,&quot;一&quot;,&quot;层&quot;,&quot;楼&quot;,&quot;,&quot;&#125;;package tech.aistar.day04;/** * 本类用来演示: 古诗词 横变竖 * * @author: success * @date: 2021/7/20 3:06 下午 */public class PoemsDemo &#123; public static void main(String[] args) &#123; String[][] arr = new String[4][6]; arr[0]=new String[]&#123;&quot;白&quot;,&quot;日&quot;,&quot;依&quot;,&quot;山&quot;,&quot;尽&quot;,&quot;,&quot;&#125;; arr[1]=new String[]&#123;&quot;黄&quot;,&quot;河&quot;,&quot;入&quot;,&quot;海&quot;,&quot;流&quot;,&quot;.&quot;&#125;; arr[2]=new String[]&#123;&quot;欲&quot;,&quot;穷&quot;,&quot;千&quot;,&quot;里&quot;,&quot;目&quot;,&quot;,&quot;&#125;; arr[3]=new String[]&#123;&quot;更&quot;,&quot;上&quot;,&quot;一&quot;,&quot;层&quot;,&quot;楼&quot;,&quot;,&quot;&#125;; change(arr); &#125; public static void change(String[][] arr)&#123; String[][] temp = new String[6][4]; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; temp[j][i] = arr[i][j]; &#125; &#125; for (int i = 0; i &lt; temp.length; i++) &#123; for (int j = 0; j &lt; temp[i].length; j++) &#123; System.out.print(temp[i][j]+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 数组排序简介:重点掌握冒泡,选择,快速排序 冒泡排序相邻的俩个进行俩俩比较. 每一轮比较完 - 确定一个最值 9 3 1 7 5 2 1 3 9 1 7 5 2 1 3 1 9 7 5 2 1 3 1 7 9 5 2 1 3 1 7 5 9 2 1 3 1 7 5 2 9 1 3 1 7 5 2 1 9 选择排序9 3 1 7 5 2 6 arr[0] -&gt; 依次和 后面所有的元素进行比较 3 9 1 7 5 2 6 1 9 3 7 5 2 6 确定最值 arr[1] -&gt; 依次和后面的所有的元素进行比较 1 2 9 7 5 3 6 直接插入排序简介:最简单的 将数组中剩余的值(从数组中第2个位置开始)依次直接插入到前面,保证前面的序列仍然是一个有序的序列 {3,1,2,5,4,6} {3,1,2,5,4,6} {1,3,2,5,4,6} {1,2,3,5,4,6} … 快速排序 算法思想: 分治思想:比大小,再分区 从数组中取出一个数,作为基准数 分区:将比这个数[基准数]大或者等于的数全部放在它的右边,小于它的数全部放在它的左边 再对左右分区间重复第二步骤,直到各分区只有一个数 实现思路: 挖坑填数 将基准数挖出形成第一个坑 由后向前找比它小的数,找到后挖出此数填到前一个坑中 由前向后找比它大或等于的数,找到后也挖出此数填到前一个坑中 再重复执行2,3两步骤.例如对5391672408 元素 5 3 9 1 6 7 2 4 0 8 坑位 坑1 坑3 坑5 坑7 坑6 坑4 坑2 0 3 4 1 2 基准数5 7 6 9 8 坑位 pos 元素 5[基准数] 3 9 1 6 7 2 4 0 8 坑位 坑1 坑3 坑5 坑7 坑6 坑4 坑2 0 3 4 1 2 基准数5 7 6 9 8 坑位 第一次重合的位置 第一轮以数组中的第一个元素5为基准数 - 经过一轮循环走完 - 以5位置为基准,左边的都是比5小的值,右边的都是大于或者等于5的数字 - 关键就是找到重合的位置!!!(分区 - 递归调用) int[] arr = {5,3,9,1,6,7,2,4,0,8}; 其他排序 希尔排序 堆排序 归并排序","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"base","slug":"base","permalink":"http://example.com/tags/base/"}]},{"title":"day03","slug":"day03","date":"2021-07-20T11:44:31.000Z","updated":"2021-07-20T11:45:32.967Z","comments":true,"path":"2021/07/20/day03/","link":"","permalink":"http://example.com/2021/07/20/day03/","excerpt":"","text":"方法的重载(@overload) 前提: 重载的方法是存在于同一个类中 [前提] 重载的方法的方法名必须相同 重载的方法的参数列表必须不相同 重载的方法的返回类型可以不一样,可以一样 1234567891011121314public class LoadMethodDemo &#123; public static void main(String[] args) &#123; add(20); &#125; public static int add()&#123; System.out.println(&quot;add -&gt; 100&quot;); return 100; &#125; public static void add(int i)&#123; System.out.println(i); &#125;&#125; 优点就是简化api - 方便调用的. 学会使用api 通过学习java.lang.Math - 数学工具类 - 提供了很多关于数学计算的方式. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package tech.aistar.day03;/** * 本类用来演示: java.lang.Math * * @author: success * @date: 2021/7/19 8:59 上午 */public class MathDemo &#123; public static void main(String[] args) &#123; //绝对值 int n = Math.abs(-10); System.out.println(n); //求随机数 - 伪随机的 //static double random();//[0.0,1.0)之间的随机小数 System.out.println(Math.random()); //[1,100]之间随机的整数 int result = (int) (Math.random()*100+1);//[1,100] System.out.println(result); //[3,5]之间的随机整数 int m = (int) (Math.random()*3+3); System.out.println(m); //求俩个数中的最大值/最小值 System.out.println(Math.max(10,20));//20 //笔试填空题 - //返回小于或等于参数的最大（最接近正无穷大） double值，等于一个数学整数。 //floor方法. System.out.println(Math.floor(3.5));//3.0 System.out.println(Math.floor(4.0));//4.0 System.out.println(Math.floor(-3.5));//-4.0 //返回参数中最接近的 long ，其中 long四舍五入为正无穷大。 //Math.floor(a + 1/2) System.out.println(Math.round(-3.5)); //开根 System.out.println(Math.sqrt(9));//3.0 //次方 System.out.println((int)Math.pow(2,3));//8 &#125;&#125; 语句三元操作符 三目运算符 条件表达式 ? result1 : result2 表达式为true,结果就是result1,否则结果是result2 支持无限嵌套的 - 但是不推荐,可读性差 m ? (表达式?result1:result2):result2 if…else.. if语句单独使用场景 123if(条件)&#123;//成立 //code...&#125; {}可以省略的场景 1234if(条件) //code...如果if&#123;&#125;中的代码只有1行,那么&#123;&#125;可以省略,但是一定要缩进 if…else…使用 1234567891011if(条件)&#123; //条件成立&#125;else&#123; //条件不成立&#125;//如果语句仍然只有一行,&#123;&#125;还是可以省略的if(条件) //codeelse //code.. 多条件分支if…else if…else..if … else… 注意条件是互斥的 123456789if(条件)&#123; //条件成立&#125;else if(条件)&#123; //条件不成立&#125;else if(条件)&#123; //code&#125;else&#123; //code..&#125; if..else语句可以无限嵌套使用 1234567891011121314151617181920212223if(条件)&#123; //条件成立 if(条件)&#123; &#125;else&#123; &#125;&#125;else if(条件)&#123; //条件不成立 if(条件)&#123; //条件成立 &#125;else if(条件)&#123; //条件不成立 &#125;else if(条件)&#123; //code &#125;else&#123; //code.. &#125;&#125;else if(条件)&#123; //code&#125;else&#123; //code..&#125; 习题 买奶茶,每第二杯半价,单价是10元.求总价. 110 5 10 5 10 求某年某月最大天数 switch..case 没有if..else if..else灵活 语法: 1234567891011121314151617switch(变量)/ /byte short int char String enum[枚举类型] //包装类型Byte Short Integer Charactercase 值1: //code [break];case 值2: //code [break];case 值3: //code [break];[default: //code.. [break];]&#125; 当switch括号中的变量能够匹配到某个case后面的值的时候,那么就会进入到对应的case中去执行里面的程序 进入到某个case块中执行的过程中,只有遇到break语句才会跳出switch块.如果没有遇到break语句,那么程序会 自动进入到下一个case块中去执行. default语句可以省略,也是可以随便放的,推荐放在末尾.如果switch括号中的变量没有匹配到任何的case后面的值 的时候,那么就会进入到default 循环语句while 属于后置循环 - 先判断循环条件是否成立,如果成立,则进入到循环体中,否则不执行循环. 使用场景:当不知道循环多少次,但是知道循环退出的条件的时候 - 优先选择while循环. 语法: while(条件){ // 循环体… } 12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day03;/** * 本类用来演示: while循环 * * @author: success * @date: 2021/7/19 10:53 上午 */public class WhileDemo &#123; public static void main(String[] args) &#123; //while可以代替for的使用 //&#x27;a&#x27;-&#x27;z&#x27; char c = &#x27;a&#x27;; while(c &lt;= &#x27;z&#x27;)&#123; System.out.println(c); c++; &#125; System.out.println(&quot;=====&quot;); //&#x27;A&#x27; - &#x27;Z&#x27; int n = 65; while(n&lt;=90)&#123;//退出的条件 System.out.println((char)n); n++; &#125; //1-10 int m = 1; //死循环... while(true)&#123; //死循环的内部一定要有打破循环的语句 - break System.out.println(m); if(m==10) // 循环退出的条件 break; m++; &#125; &#125;&#125; 练习 求俩个数的最大公约数 12345思路:20 12 -&gt; 4 20 % 12 = 8 12 % 8 = 4 8 % 4 = 0 十进制转换二进制 1 for循环 属于后置循环 单层for 1234567891011for(①表达式1;②表达式2;③表达式3)&#123; //④循环体&#125;①表达式1 - 循环过程中的变量的初始化操作.比如int i = 0; - 仅仅只会执行1次.②表达式2 - 循环退出的条件.比如 i&lt;=10 - 至少执行1次③表达式3 - 循环过程中,变量因子的变化.i++ - 有可能是不执行,可能执行执行顺序①-②[成立]-④-③-②[成立]-④-③..... 怪异的写法 1234for(;;)&#123; //死循环 - break打破循环的语句&#125;三个表达式都是可以任意的省略不写,或者写到其他地方 for循环的复合形态 123for(同时定义若干个变量;条件;表达式)&#123; //循环体...&#125; 嵌套for循环,嵌套的层数不建议超过三层.嵌套越多,性能越低. 2-1. 内外层无关 - 里面的for选中的使用可以单独执行.没有使用到外面for的循环的变量因子的. 2-2. 内外层相关 - 里面的for使用到了外面for循环的变量因子的 练习 - 打印所有的三位数.三位数由数字1,2,3,4组成.但是不能出现重复的. 每打印4个换一行 12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day03;/** * 本类用来演示: * 练习 - 打印所有的三位数.三位数由数字1,2,3,4组成.但是不能出现重复的. * * 每打印4个换一行 * * @author: success * @date: 2021/7/19 2:26 下午 */public class ForExerciseDemo &#123; public static void main(String[] args) &#123; //定义一个计数器 int count = 0; for (int x = 1; x &lt;=4 ; x++) &#123; for (int y = 1; y &lt;=4; y++) &#123; for (int z = 1; z &lt;=4; z++) &#123;// System.out.print(x+&quot;&quot;+y+z); if(x!=y &amp; x!=z &amp; y!=z)&#123; System.out.print(x*100+y*10+z+&quot;\\t&quot;); count++;// if(count % 4==0)&#123;// System.out.println();// &#125; if(count == 4)&#123; System.out.println(); count = 0; &#125; &#125; &#125; &#125; &#125; &#125;&#125; do..while.. 属于前置循环 - 无论循环条件是否成立,优先先进入到循环体中执行一次. 然后再进行判断条件,决定下一次是否再次进入. do{ //循环体… }while(条件); break语句 break可以跳出swtich块 break可以打破它所在的那一层循环 continue语句 出现在循环体中 跳过本轮循环,继续执行下一轮循环. 数组 数组的诞生 - 为了解决单个变量只能存储单个值的缺点. 数组本身也是属于数据结构[数组,栈,堆,树[红黑树],链表,图…] 数组是属于对象类型,数组是存在在JVM内存的堆区,基本类型存储在JVM内存的栈区 数组在内存中一定是一块连续的空间. 数组的大小[长度,数组中存放的数据的个数]一旦确定了,不能改变. 定义数组必不可少的俩个条件 - 元素类型/数组的长度要确定 数组容器 语法1234567891. 元素类型[] 变量名 = new 元素类型[size];//size数组的大小2. 元素类型 变量名[] = new 元素类型[size];//元素类型就是数据类型[8种基本数据类型,以及对象类型]作用 - 元素类型决定了这个数组中可以存放的数据的类型//arr的数据类型是什么?int[] -&gt; 整数型数组// &quot;定义一个长度为3的int型数组&quot;int[] arr = new int[3]; 赋值方式 如果定义了数组,但是没有进行赋值操作,那么系统会默认分配一个默认值 默认值根据元素类型来决定了. byte,short,int,long -&gt; 0 float,double -&gt; 0.0 boolean -&gt; false char -&gt; 空格 对象类型 -&gt; null 先定义数组,然后通过下标一一赋值 123456int[] arr = new int[3];//数组的下标从[0,数组长度-1]范围//如果下标不在此范围,控制台抛出java.lang.ArrayIndexOutOfBoundsException 数组下标越界异常arr[0] = 10;arr[1] = 10;arr[2] = 10; 定义数组的同时进行赋值 1int[] arr = &#123;3,4,5&#125;; 定义数组的同时进行赋值 1int[] arr = new int[]&#123;3,4,5&#125;; 通过普通for去赋值 1234int[] arr = new int[3];for(int i=0;i&lt;arr.length;i++)&#123; arr[i] = (int)(Math.random()*100+1);&#125; 数组的遍历 通过下标一一取值 1System.out.println(arr[下标]); 数组提供了属性length - 获取数组的长度 通过普通for循环进行遍历 123for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; 使用jdk5.x提供的增强for循环的语法 属于只读的for 1234567int[] arr2 = &#123;3,4,5&#125;;for(元素类型 元素变量:数组变量名)&#123; System.out.println(元素);&#125;for(int e:arr2)&#123;//此处的e不是代表下标,就是代表真正的元素 System.out.println(e);&#125; 通过java.util.Arrays数组工具类中提供的static String toString(数组对象)来遍历数组 拓展 - 数组的内存123456789101112131415//通过new关键字在Jvm的堆中开辟新的空间01,用来存储这个对象&#123;10,20,30&#125;//然后将这个对象在堆空间中的内存地址赋值给了引用变量arr1[存储在栈]//&quot;结论&quot; - arr1的本质不是对象,只是一个引用变量而已//&quot;结论&quot; - 引用和对象之间的关系// 引用变量中存储的就是对象在堆空间中的内存地址// &quot;气球理论&quot; - 一个引用变量在同一个时刻,只能指向一个对象// - &quot;一个对象可以在同一个时刻被多个引用指向&quot;int[] arr1 = new int[]&#123;10,20,30&#125;;//通过new关键字在Jvm的堆中开辟新的空间02,用来存储这个对象&#123;10,20,30&#125;int[] arr2 = &#123;10,20,30&#125;;arr1 = arr2;//arr1和arr2都是指向第二次创建出来的数组对象 //原来第一次创建出来的对象就成为内存中的垃圾对象 - GC[垃圾回收线程进行回收,释放内存] //&quot;垃圾对象&quot; - 没有任何引用指向的对象 拓展 - 方法的参数传递方式 基本类型采用值传递 对象类型[引用类型]采用地址传递 总结:**Java中只有值传递,没有地址传递.**比较特殊的是String类型[虽然是一个对象类型,但是具备基本类型传递的特点] 数组工具类 java.util.Arrays static String toString(int[] arr);//输出数组 static int[] copyOf(int[] original, int newLength) 复制指定的数组，用零截取或填充（如有必要），以便复制具有指定的长度。 static void fill(boolean[] flag,boolean value);//给数组赋统一的值.","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"base","slug":"base","permalink":"http://example.com/tags/base/"}]},{"title":"day02","slug":"day02","date":"2021-07-16T11:42:19.000Z","updated":"2021-07-20T10:58:36.068Z","comments":true,"path":"2021/07/16/day02/","link":"","permalink":"http://example.com/2021/07/16/day02/","excerpt":"","text":"变量的定义和使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package tech.aistar.day02;import java.util.Date;/** * 本类用来演示: 变量的定义和使用 * * @author: success * @date: 2021/7/16 8:35 上午 */public class VarInitDemo &#123; public static void main(String[] args) &#123; byte b = 127; short s = 100;//使用频率很少 //开发中常用的整数型类型 - int,long //int类型可以初始化的值有哪些 int a = 100; //存储一个二进制,只要0b二进制,1010对应的十进制 //java中的int类型表示的是十进制的数据 //1010 = 1*2^3+1+2^1 = 10 int a1 = 0b1010; System.out.println(a1); //java中使用单引号来表示一个字符 //&#x27;a&#x27;-&gt;char类型-&gt;int类型 //&#x27;a&#x27;对应的ascii码97 //&#x27;A&#x27;对应的ascii码是65 //&#x27;0&#x27;对应的ascii码是48 int a2 = &#x27;a&#x27;; System.out.println(a2); //java中以0开头的代表是八进制 //八进制转换十进制032 = 3*8^1 + 2*8^0 = 26 int a3 = 032; System.out.println(a3);//26 //长整型 - long //int类型-&gt;long类型 long x1 = 100; //推荐定义long的方式采用隐式转换 long x2 = 200L; //jdk7.x提供的 - 为了增强数字的可读性而已. long x3 = 3_14_15_926L; System.out.println(x3);// Date date = new Date(3L*24*60*60*100*1000*1000*2000);// System.out.println(date); //浮点数 - 并不是用来进行精确计算的 //后面java.math.Decimal类解决小数计算的时候精度丢失的问题. double d = 1.75; //推荐定义double double d2 = 5.67D; //float的精度是7或者8 //double的精度是16 //double类型强制转换成float类型 float f = (float) 3.14; //隐式转换 float f2 = 3.14F; System.out.println(f2); //补充 //数字进行计算的时候,都会转换成二进制进行计算 //小数进行计算的时候,还是不可逆的 //0.8999999999999999 System.out.println(2.0-1.1); //0.9 System.out.println(2.0f - 1.1f); //int-&gt;float × //int-&gt;double √ int n = 123456789; float ft = n; System.out.println(ft);//1.23456792E8 double db = n; System.out.println(db);//1.23456789E8 float f3 = 1.234567565f; System.out.println(f3);//1.2345675 //定义布尔类型 boolean flag = true; System.out.println(flag); //最特殊的是char类型 char c = 65; System.out.println(c); &#125;&#125; char类型 java中是使用单引号表示char类型,使用双引号来表示字符串. java的底层的编码是unicode编码,char类型也是采用unicode编码 unicode编码是双字节[16bit],所以存储一个汉字. ascii码和unicode码的关系? 不同的国家,符号表示的方式不同,所以ascii码[0127]不够用.所以unicode[065535]码诞生了,几乎 包含了所有国家的符号,unicode码包含ascii码.char类型在进行计算的时候会转换成ascii码来进行计算. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day02;/** * 本类用来演示: char类型 * * @author: success * @date: 2021/7/16 9:14 上午 */public class CharDemo &#123; public static void main(String[] args) &#123; //java中是使用单引号表示char类型 //char的空间大小也是确定的 char c = &#x27;a&#x27;; System.out.println(c); //十六进制 //由数字0-9或者字母a-f/A-F,字母a代表就是数字10 //cmd - 输入native2ascii -&gt; 输入中文 char c2 = &#x27;\\u34af&#x27;; System.out.println(c2); //char底层采用的是unicode编码,所以存储一个汉字 char c3 = &#x27;星&#x27;; System.out.println(c3); char c4 = 48; System.out.println(c4); int m = 48; char c5 = (char) m; System.out.println(c5); //char类型在进行计算的时候会转换成ascii码来进行计算. //&#x27;a&#x27; = 97,&#x27;A&#x27; = 65,&#x27;0&#x27; = 48 //char类型的计算 - 进阶部分 char n1 = &#x27;a&#x27; + 1;//ok System.out.println(n1);// &#x27;b&#x27; char cc = &#x27;a&#x27;; char nn = (char) (cc + 1); System.out.println(cc); //char-&gt;int int result = &#x27;a&#x27; + &#x27;b&#x27;;//ok System.out.println(result);//195 &#125;&#125; 变量的赋值方式 单个赋值 int a = 10; 通过表达式赋值 1234int a = 10;int b = 20;//表达式:由字面量或者变量以及运算符号组成的合法的语句int result = a + b; 链式赋值 123int a=10,b=20,c=30;//同时声明了三个变量,并且都进行初始化int a,b,c = 100;//此处仅仅是对c进行赋值操作,如果一个局部变量没有进行赋值,那么将不能够使用 可以先定义变量,然后再进行赋值 1234int a;a = 10;a = 20;System.out.println(a); 通过方法进行赋值 - 暂时了解 12345678910int result = getResult(); /** * 自定义了一个方法 - 千万不要将它放在main方法中 * java语法 - 方法体内部是不能够再去定义方法的 * @return 整数 */public static int getResult()&#123; return 100;&#125; 变量的分类 局部变量 - 定义在方法体内部 使用的范围就是在它所在的最近的那个{}中 全局变量 - 定义在方法体外部的变量 生命周期 - 面向对象 常量 使用final修饰的变量 - 常量 - 不可改变的量 语法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546final 数据类型 变量 [= 初始值];package tech.aistar.day02;/** * 本类用来演示: 局部变量和全局变量 * * @author: success * @date: 2021/7/16 10:04 上午 */public class LocalVarAndGlobalDemo &#123; //定义全部变量 static int c = 100;//静态变量 - 暂不了解 public static void main(String[] args) &#123; //代码块 //局部变量 - 定义在方法体内部 int a= 10; &#123;// 使用的范围就是在它所在的最近的那个&#123;&#125;中 int b = 20; System.out.println(a);//ok System.out.println(b);//ok &#125; //使用的范围就是在它所在的最近的那个&#123;&#125;中 //System.out.println(b);//error //访问全局变量 System.out.println(c); //定义一个常量 - 不可改变的量 final int s = 100; //s = 200; //final - b肯定不可变 final byte b = 100; byte result = b + 1;//ok &#125;&#125; 运算符算术运算符12345678910111213141516171819201. + java语言中唯一重载[具有多个意义]的运算符 数值之间表示的加法运算,如果出现了&quot;字符串&quot;,表示拼接[后面就会知道拼接效率很低] 2. - 减法 * 乘法 3. / 除法[配合计算过程中需要注意的结果的类型而已] - 取整 4. % 取余/模 /和%结合使用,可以获取某个数字任意位上的数值. 5. += -= *= /= %= 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 6. ++和-- 前++/后++ - 变量本身都会自增1 前--/后-- - 变量本身都会自减1 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 比较运算符12&gt; &lt;= &gt;= &lt; !=比较得到的结果是一个boolean类型即可 逻辑运算符 &amp;&amp; - 逻辑与,短路与.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 所有的条件表达式都是返回true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为false的放在最左边 - 提高代码的执行效率. || - 逻辑或,短路或.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 只要有一个表达式是true,那么结果就是true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为true的放在最左边 - 提高代码的执行效率. ! - 逻辑非,true成为false,false成为true 位运算符 &amp; - 按位&amp;,非短路与,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:都是1,结果才是1.只要出现1个0,那么结果就是0 连接条件:为true - 所有的条件表达式都是返回true 123456789101112131415~~~java10 &amp; 8 = 8 十进制的数不断除以2,直到商为0,然后倒过来取余数 - 101010 / 2 = 商5......余05 / 2 = 商2 ...... 12/ 2 = 1 ........ 01/2 = 0 .........1 1 0 1 0 &amp; 1 0 0 0------------------ 1 0 0 0 -&gt; 对应的十进制8~~~ | - 按位或,非短路或,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:只要存在一个1,结果就是1 连接条件:为true - 只要存在一个条件表达式为true. 123456710 | 8 = ? 1 0 1 0| 1 0 0 0------------------ 1 0 1 0 -&gt; 对应的十进制10 异或^ 作用:进行计算的 - 相同为0,不同为1 12345678910 ^ 8 = 2 1 0 1 0 | 1 0 0 0------------------ 0 0 1 0 -&gt; 2 10 ^ 8 ^ 8 = 10 12340 0 1 0 1 0 0 0----------------- 1 0 1 0 -&gt; 10 结论:一个数字连续异或同一个数字俩次结果是它本身. 可以进行加密和解密的操作 1234567891011121314151617181920212223242526272829303132333435363738394041笔试题: 交换俩个变量的值,不允许出现第三方变量package tech.aistar.day02; /** * 本类用来演示: 笔试题: 交换俩个变量的值,不允许出现第三方变量 * * @author: success * @date: 2021/7/16 11:09 上午 */public class ChangeVarValue &#123; public static void main(String[] args) &#123; //1. 使用第三方变量 int a = 10; int b = 20; int temp = a; a = b; b = temp; System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+b); //一个数字连续异或同一个数字俩次结果是它本身. int m = 100; int n = 200; m = m ^ n;//m = 100 ^ 200 n = m ^ n;//n = 100 ^ 200 ^ 200 = 100 m = m ^ n;//m = 100 ^ 200 ^ 100 = 200 System.out.println(&quot;m:&quot;+m); System.out.println(&quot;n:&quot;+n); //自创写法(success独家的) - 不推荐写 - 防止菜鸟看不懂 int x = 100; int y = 200; //y = 100 ^ 200 ^ 200 = 100 y = x ^ (x = y) ^ y; System.out.println(&quot;x:&quot;+x); System.out.println(&quot;y:&quot;+y); &#125;&#125; 取反~,1变0,0变成1 补码 - 负数在计算机中的表现形式就是以补码的形式存在的 123456789101112131415161718192021222324252627282930补码 = 反码 + 1;反码 = 原码符号位不变,其余位依次取反符号位 - 最高位代表的是符号位.1代表的是负数,0代表的是正数.反码本身没有意义的,它的存在就是为了计算补码正数的补码,反码,原码都是它本身.计算一下:-10的二进制是多少?-10的补码是多少? 计算步骤:1. -10原码 10000000 00000000 00000000 000010102. -10的反码 10000000 00000000 00000000 00001010 11111111 11111111 11111111 11110101 3. -10的补码 = 反码+1 11111111 11111111 11111111 11110101 + 1 ------------------------------------- 11111111 11111111 11111111 11110110 -&gt; -10的二进制 计算~900000000 00000000 00000000 0000100111111111 11111111 11111111 11110110 -&gt; ~9取反的结果 -10 = ~9 结论:-(x+1) = ~x 移位操作 笔试题 - 计算性能最高的操作,jdk源码里面很多都是移位操作 12345678910111213141516171819&lt;&lt; 向左移动 2&lt;&lt;2 =&gt; 0010 &lt;&lt; 2 = 1000 = 8 原题:请你用最高性能的方式计算出2的3次方.&gt;&gt; 带符号的右移动,向右移动多少位,那么就在最高位补符号位 -10 &gt;&gt; 2 = -3 11111111 11111111 11111111 11110110 &gt;&gt; 2 11111111 11111111 11111111 11111101 -&gt; 负数的二进制,最高位是1 00000000 00000000 00000000 00000010 取反 ~2=-3 &gt;&gt;&gt; 不带符号的右移动,向右移动多少位,就在最高位补0 -10 &gt;&gt;&gt; 2 11111111 11111111 11111111 11110110 &gt;&gt; 2 00111111 11111111 11111111 11111101 -&gt; 计算出十进制 01000000 00000000 00000000 00000000 - 3----------------------------------------- 1073741821 练习-15&gt;&gt;2 -15&gt;&gt;&gt;2 -15 = ~14 11111111…… 0001 &gt;&gt;&gt; 2 00111111 11111111 11111111 11111101 00111111 11111111 11111111 1111100 = 1073741820 方法 - Method 非常重要,如果没有跟上,直接出局. 相当于其他语言中函数function,功能是用来封装代码的逻辑. 把一段代码封装到方法中,方便以后复用,提高了代码的可维护性. 语法1234修饰符 返回类型 方法名([参数列表]) [throws 可抛出的异常列表]&#123;..方法体...&#125;现阶段:修饰符 返回类型 方法名([参数列表])&#123;..方法体...&#125; 修饰符访问修饰符 作用:就是决定了这个方法可以被调用的范围. public - 公开的,公共的.如果一个方法被public进行了修饰,那么代表这个方法可以在别的地方被调用. private - 私有的,只能在当前类内部被调用 - 体现了”封装性” - 不对外公开的. 默认的 受保护的 特殊修饰符[超纲的内容] static - 静态的 如果使用static修饰的方法 - 静态方法 如果没有使用static修饰的方法 - 非静态方法 是否为静态的方法决定了这个方法被调用的方式. 返回类型 有返回类型 可以是八种基本数据类型,也可以是对象类型[内置对象类型或者自定义对象类型] 方法体的最终的出口一定有return 返回值. 12345678return 作用1 - 返回方法最终的执行结果 作用2 - 用来结束整个方法正常情况方法的返回类型是什么,返回值的结果的类型也应该是什么非正常情况 - 支持类型的自动转换和强制类型转换的.调用的时候 - 需要使用数据类型和变量来接受这个方法调用的结果. 方法的返回类型是什么,就用什么类型去定义.当然也是支持类型的转换 无返回类型 - void 123456789不需要使用return + 返回值;但是void的方法体中也是可以存在return语句.就是用来结束整个方法的. if(条件)&#123; //.... return;&#125;//... 该如何选择? 如果某个方法的执行结果可能在另外一个地方被使用到,那么一定要定义成有返回类型 如果一个方法仅仅是为了输出,只要定义void 123456789101112131415public static int test01(int m,int n)&#123; //code... return m和n的最大公约数 //System.out.println(公约数)&#125;//int m = test01(20,12);//m-&gt;4public static int test02(int m,int n)&#123; int 公约数 = test01(m,n); return m*n/公约数;&#125;int n = test02(20,12);//n-&gt;60=20*12/4=60 方法名 参考变量名的命名规则 - 一模一样 标识符 - 给类,包,变量,方法取的名称 参数列表 无参列表 带参列表 - 固定长参数列表 1234//此处的age和name就是形参public static void add(int age,String name)&#123; System.out.println(age+&quot;:&quot;+name);&#125; 可变长列表 123456//可变长列表public static void sub(int... arr)&#123;//[I@330bedb4 - 数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 参数的分类: 形参 - 定义在方法的参数列表中的参数.目的就是告诉这个方法的调用者在调用这个方法时候需要传入的参数[个数以及类型] 没有实际的值的 实参 - 方法的调用者在调用这个方法的时候传入的真正的参数 - 真正的值的 该如何定义方法 方法体内部不能够再去定义方法了 main方法仍然是程序的主入口. 自定义的方法希望能够被调用,那么最终肯定是在main方法中进行调用的 方法的调用方式 取决于这个方法是静态的还是非静态的 - static 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package tech.aistar.day02.method;/** * 本类用来演示: 方法的定义 * * @author: success * @date: 2021/7/16 2:20 下午 */public class MethodHelloDemo &#123; /** * main - 仍然是程序的主入口 * @param args */ public static void main(String[] args) &#123; //类中的方法 - 类里面的成员 //static - 静态的成员被初始化的时机 //静态方法什么时候被初始化的? - 当JVM加载类进内存的时候,就会立即给所有的静态的成员分配空间以及初始化 //在这个阶段,压根就没有对象的概念,只有类. //结论 - 静态的成员属于类的,并且初始化的时机有且1次. //属于谁,就由谁去调用! //1. 调用静态的方法,直接通过类.方法名([参数]) //类 - 该静态方法所在的当前类 MethodHelloDemo.sub(); //non-static -&gt; 非静态的成员被初始化的时机? //当遇到创建对象的语法.每次创建对象的时候,都会给各自的非静态成员分配空间以及初始化 //如果没有创建对象,就不会初始化这些非静态成员. //结论: 非静态成员是属于对象的.属于谁,由谁调用. //2. 非静态方法 - 通过对象去调用 //调用哪个类中的方法,就去创建哪个类的对象 //后面的OO知识点 -&gt; 类名 变量 = new 类名(); //创建了一个 MethodHelloDemo对象,m就是对象名 MethodHelloDemo m = new MethodHelloDemo(); m.add(); &#125; /** * 定义了公开的非静态的无返回类型的方法 */ public void add()&#123; System.out.println(&quot;add...&quot;); &#125; /** * 定义了公开的静态的无返回类型的方法 */ public static void sub()&#123; System.out.println(&quot;sub...&quot;); &#125;&#125; 静态方法中只能够直接调用静态方法 非静态方法中可以直接调用非静态方法以及静态方法 通用的原则 - 类名.静态方法或者对象.非静态方法 静态方法属于类拥有的,非静态方法属于对象拥有的 静态的方法是jvm加载类进内存的时候就会立即被分配空间以及初始化,并且机会仅仅只有1次. 而非静态方法必须是等到创建对象的时候,才会被分配空间以及初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package tech.aistar.day02.method;/*** 本类用来演示:** @author: success* @date: 2021/7/16 2:43 下午*/public class StaticDetailDemo &#123; //定义了全局变量 //属性,方法 =&gt; 成员 //非静态的属性 int n = 10;//等创建对象的时候,才会分配空间和初始化 //静态属性-初始化的时机优先于静态方法 static int m = 100; public static void main(String[] args) &#123; //此时n还未初始化 //System.out.println(n);//编译错误 //System.out.println(m); //调用test03 - 非静态的 StaticDetailDemo s = new StaticDetailDemo(); s.test03(); System.out.println(s); &#125; //非静态的 public void test01()&#123; System.out.println(&quot;test01..&quot;); &#125; //静态的 public static void test02()&#123; int n = 10; System.out.println(&quot;test02...&quot;); //自定义的方法中是可以调用自己自定义的方法的 //1. 另外一个静态方法test04 StaticDetailDemo.test04(); //静态方法中可以直接调用静态方法 test04(); //2. 另外一个非静态方法test03 StaticDetailDemo s1 = new StaticDetailDemo(); s1.test03(); &#125; public void test03()&#123; //static int n = 20;//非静态方法中不允许定义静态的局部变量 System.out.println(&quot;test03..&quot;); //非静态方法中调用静态方法 - 类名.方法 //StaticDetailDemo.test04();//ok test04();//ok //非静态方法中直接调用另外一个非静态方法呢??? - 肯定是需要一个对象去调用. test01();//ok //实际上省略了一个关键字this //this代表的是当前对象 //当前对象 - 调用该方法[test03]的对象 //this.test01(); System.out.println(this); &#125; public static void test04()&#123; System.out.println(&quot;test04..&quot;); &#125;&#125; 方法调用补充 方法的调用者和方法的定义者在同一个类中. 方法的调用者和方法的定义者不在同一个类中,但是仍然在同一个package中. 只能使用通用的原则类名.静态方法或者对象.非静态方法 方法的调用者和方法的定义者是存在于不同包下的不同类中. 必须先通过import关键字进行导包操作. 使用jdk中的类的时候,除了java.lang包下的不需要手动import,其余包下的都需要先import 递归算法 - 错误的写法 - 方法内部直接调用自己 private 和 public 该选择使用123456789101112131415161718192021222324252627public class 牛叉的工具类&#123; public static void 牛叉的方法01()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //.. //... &#125; private static void 小的牛叉方法01()&#123; //专门封装了小的功能. &#125; public static void 牛叉的方法02()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //... //... &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"base","slug":"base","permalink":"http://example.com/tags/base/"}]},{"title":"day01","slug":"day01","date":"2021-07-15T11:55:53.000Z","updated":"2021-07-16T11:41:07.383Z","comments":true,"path":"2021/07/15/day01/","link":"","permalink":"http://example.com/2021/07/15/day01/","excerpt":"","text":"Java能做什么 传统的项目 - 简单的,公司内部使用的,不会存在高并发的问题. 教务管理系统,OA自动化办公系统,CRM客户关系管理系统,ERP企业资源计划系统 B2C - 典型的电子商务模式,涉及到高并发的业务 企业2客户 - 企业卖自己的服务或者产品 C2B2C - 新型的模式 - 淘宝 平台 - 对双方进行监管 卖家 买家 大数据 - 一定是对业务非常熟悉[数据分析,数据非常敏感] Java的历史 原先是属于SUN公司[Stanford University Network 斯坦福网络大学] Sun Microsystem - 太阳微电子公司 后来在2010年10月份被Oracle公司[出名的产品-oracle数据库 - NO.1] 74亿美金收购 - www.oracle.com 前身Oak语言[橡树],印度尼西亚的爪哇岛[咖啡豆 - javabean] 诞生于1995年5月23日,96年正式推出jdk1.0版本. 商用的jdk版本 - jdk8.x , jdk11.x ,jdk16.x java之父 - james gosling 詹姆斯 高斯林 Java支持的三个平台 原先的名称j2se , j2ee, j2me JavaSE - Java Standard Editional - Java标准版 适合做桌面应用程序[维护比较麻烦,服务器端如果更新,客户端需要更新],包含了java里面的基础的语法,核心 JavaEE - 2018年 - JakartaEE - 雅佳达EE - Java Enterprise Editional - Java企业版 是一套技术的规范的体系.不是一门具体的技术.里面包含了13种核心技术 比如jdbc,servlet等遵守javaee的规范.现在javaee里面的核心技术已经使用不多了 现在普遍都在使用spring全家桶中的技术. 适合做web应用程序[web网站] JavaME - Java Micro Editional - Java微型版,适合做手持设备 - “不用” 检测一下jdk的环境变量是否配置成功 打开终端,输入cmd - 输入java -version 1234admindeMacBook-Pro:Desktop admin$ java -versionjava version &quot;1.8.0_66&quot;Java(TM) SE Runtime Environment (build 1.8.0_66-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode) 环境变量的配置 Java.zip - 解压缩 - 比如放在D盘 所有的软件不要放在中文目录下,不要放在带有特殊符号的目录下[programe files(x86)] 尽量不要放在C盘[权限的问题,拒绝你的访问的] 桌面 - 右击计算机 - 属性 - 高级系统设置 - 环境变量(N) - 定位到系统变量 新建 变量名:JAVA_HOME 变量值:jdk1.8.0_66的绝对路径 确定 找到内置的变量名Path - 编辑 - 新建 %JAVA_HOME%\\bin 关闭刚所有打开的设置窗口,重新打开终端[黑窗口] win+r - cmd -&gt;输入 java -version Java语言特点 简单 可移植性 面向对象 - 核心 与平台无关性[跨平台性,跨操作系统平台] 安全性 - 本身是属于强类型的语言.在编译期间就要确定数据的类型. JDK和JRE和JVM 三者之间的区别 - 简单题 - 笔试 JDK - Java Development Kit - Java开发工具包,针对于开发者的.包含了很多开发工具 比如java.exe , javac.exe, javadoc.exe , jar.exe等 JDK中是包含JRE的 JRE - Java Runtime Enviroment - Java运行时环境,包含了很多核心的内库. 针对于使用java语言开发出来软件的用户.如果一个用户仅仅想运行一个java程序的话 那么计算机中只需要安装jre即可. JRE包含JVM JVM - Java Virtual Machine - Java虚拟机 - 后期重点详细介绍jvm[笔试的大头 - 内存模型] jvm本身就是用C语言编写的 - jvm的源码通读一遍. java程序并不是直接在计算机中进行跑的.而是在虚拟机上执行的.虚拟机是安装在操作系统上的. 注意的是java语言是跨平台的[使用java语言编写的程序可以运行在不同的os上],但是jvm不是跨平台的 不同的操作系统需要安装不同的jvm HelloWorld程序 java的基础单元是类class 类的命名 - 标识符的命名 只能由字母,数字,下划线,$符号组成,但是不能以数字开头 推荐使用”大驼峰”命名规则,单词首字母必须要大写.其余单词小写 不能是jdk中内置的对象类型[String,System] 不能是java中的一些关键字,关键字[java语言赋予了这些单词具备一定的语法含义] byte,short,int,long,float,double,char,boolean,if,for,else,while,break,continue,class, public,private,protected等 不能是java中的保留关键字 - goto,const 不推荐使用中文,防止出现乱码问题. 不推荐使用中文的拼音 推荐见名知意 代码 在D盘根目下新建一个文件HelloWorld.java java的源文件就是以.java为后缀的文件 记事本打开HelloWorld.java文件 12345678910111213141516171819//编程语言中,只要出现了符号,一定必须都是英文输入法下的//整体的结构//java是以类作为基础的单位的 - 定义类//关键是class//类的名称要和文件的名称高度保持一致//&#123;&#125; - block - 块 - 代码块public class HelloWorld&#123;//1. 类 //规范 - 缩进四个空格 //定义一个main方法 - 程序的&quot;大门&quot; //运行该程序的时候,jvm就会自动寻找main方法,然后进入到这个main //方法中去执行 //今天先记住语法 public static void main(String[] args)&#123;//2. 方法 //方法体,现阶段代码一定是放在方法体内部的. //jdk中提供了内置的对象[拥有一些功能],提供好了,开发者就可以直接使用 //java.lang.System类 - 向控制台输出一句话 System.out.println(&quot;HelloWorld&quot;);//3. 具体的程序 &#125;&#125; java源代码是不能够直接执行的.因为计算机是不识别java语言程序的. 需要对.java为后缀的源文件进行一个编译操作.如果一旦语法发生了问题,都会导致编译失败. 假设HelloWorld.java文件是放在D盘根目录下,需要打开终端,然后通过dos命令进入到D盘 12C:/User/admin&gt;d:D:/&gt;javac HelloWorld.java 效果,javac.exe工具其实就是在调用jdk中的编译器,作用:就是.java源文件编译成.class字节码文件 思考如何运行一个java程序呢? 利用java.exe 1D:/&gt;java HelloWorld 过程 编写.java源代码 javac.exe - 编译 java.exe - 执行 Java程序的执行的原理 12345678.java源文件 -&gt; 经过jdk中的编译器,成为.class字节码文件 -&gt; 经过jvm中的解释器[进行逐行翻译(解释)]-&gt; 机器能够识别的符号java属于解释型的语言,&quot;JVM把它YY成以.class字节码为指令的CPU&quot;编译型语言 - C语言,将这个语言编写的程序直接编译成计算机能够执行的程序.比如C语言写的代码可以直接编译成可执行文件 xx.exeC语言执行的性能高于java语言(每次执行都会经过jvm解释器进行解释) 集成开发环境 eclipse[日食] - 免费的,IBM公司的产品[收购SUN公司的] idea - 最好的,收费的 d:/aistar/j03s_student Java中的包-package 包是用来管理类的.包的本质就是一个文件夹.包对于类的作用相当于文件夹对于文件的作用. 包的命名规则 2-1. 推荐全部采用小写字母,如果出现多个单词,请你用.隔开,.隔开的每个部分都是一个目录 2-2. 包的命名推荐采用公司的域名倒置[唯一性] + 项目代号 com.baidu.car tech.aistar 2-3. 不用采用java或者javax开头 - 因为jdk中的内置的类和拓展的类都是在java或者javax包中. 一旦创建了package,需要在类文件的首行采用package关键字来声明包. java中三种注释 单行注释 // ctrl+/ 添加/取消注释 多行注释 12345/* * * 多行注释的内容 - 注释的内容是不会经过jdk的编译器的 * */ 文档注释 可以生成文档树 123456/*** 放在类上面* 放在方法上**/ main方法细节12345678910public[公开的,公共的] static[静态的] - 都是属于后期学习OO中的修饰符修饰符在使用的时候,之间是没有顺序的.public static void main(String[] args)&#123;...&#125; //okstatic public void main(String[] args)&#123;...&#125; //ok//jdk8中方法的参数支持可变长参数public static void main(String... args)&#123;...&#125; //ok//args - 我们传给虚拟机的参数 输出语句 System.out.println(); // 换行 1System.out.print(&quot;\\n&quot;); \\n和\\r 1234567891011121314151617181920212223242526package tech.aistar.day01; /** * 本类用来演示: \\n \\r * * @author: success * @date: 2021/7/15 3:18 下午 */public class NrDemo &#123; public static void main(String[] args) &#123; //相当于是System.out.println(&quot;hello&quot;); System.out.print(&quot;hello\\n&quot;);//输出之后不换行 System.out.println(&quot;world&quot;); // \\n - 当输出完毕之后,光标停在下一行的起始位置 - 换行 // \\r - 当输出完毕之后,光标停在当前行的起始位置 回车 // \\n\\r 诞生的场景就是早期的打字机 //外面的终端执行的结果是 - veyy √ //伪终端显示的结果是 - ve System.out.println(&quot;Loyy\\rve&quot;); &#125;&#125; 特殊字符 \\ 是代表转义字符 \\n - 当输出完毕之后,光标停在下一行的起始位置 - 换行 \\r - 当输出完毕之后,光标停在当前行的起始位置 回车 \\b - 退格 \\t - 制表符,相当于tab键,默认是空4格 双引号 1\\&quot; 单引号 1\\&#x27; 单个\\ 1\\\\ 123456789101112131415161718192021222324252627282930package tech.aistar.day01;/** * 本类用来演示: 特殊字符 * * @author: success * @date: 2021/7/15 3:35 下午 */public class SignDemo &#123; public static void main(String[] args) &#123; //\\b - 退格 System.out.println(&quot;xxx\\byy&quot;);//xxyy //\\t - 制表符,相当于tab键,默认是空4格 System.out.println(&quot;hello\\tworld&quot;); //输出 james:&quot;success is good boy&quot; //双引号 System.out.println(&quot;james:\\&quot;success is good boy\\&quot;&quot;); // \\ 转义含义 //单个\\ System.out.println(&quot;D:\\\\temp\\\\news&quot;); //输出\\\\ System.out.println(&quot;\\\\\\\\&quot;); &#125;&#125; 变量 编程的核心就是从定义变量开始 java语言是一个强类型的语言[在编译期间必须要确定好数据的类型],javascript弱类型的语言 变量的本质 - “内存中某块区域的名称”,编程的任务就是对数据进行crud+数据分析的操作. 但是前提是数据需要先进行存储[内存,磁盘(文件,db数据库) - JVM内存 “JVM对字节码文件进行解释的前奏工作 - 把这个字节码文件加载到自己的内存中,java只能操作内存中的数据” java中是如何定义和存储简单的这些数据呢? 就是通过数据类型以及变量来定义和存储的. 数据类型 java中的数据类型有两大块 基本数据类型(8种) - 编程思想中将void归纳为第9种 数据类型决定了存储数据的这块空间的大小,并且这个大小一旦确定了,将不能够改变了. 对象类型(无数种) 2-1. 内置对象类型 - System,String - Jdk中提供的类 2-2. 自定义对象类型 - 自己定义的那些类HelloWorld,SignDemo 八种基本数据类型 名称 大小 范围 默认值 byte 字节 占1个字节8bit -128~127 0 short 短整型 占2个字节16bit -2^15~2^15-1 0 int 整型 占4个字节32bit -2^31~2^31-1 0 long 长整型 占8个字节64bit -2^63~2^63-1 0 float 单精度浮点数 占4个字节32bit +-(3.4*10^38) 0.0 double 双精度浮点数 占8个字节64bit +-(1.798*10^308) 0.0 char 字符 占2个字节16bit 0~65535 ‘\\u0000’空格 boolean 布尔类型 占1个字节8bit true/false false 变量的定义 变量的命名的规范请你参考类的命名规范,除了类的命名采用的”大驼峰”,而变量命名采用的是”小驼峰” “小驼峰” - 首字母小写,其余每个单词的首字母大写.比如studentAge 12语法数据类型 变量名 [= 变量值]; 剖析变量的背后12345678910111213141516171819202122232425262728293031323334353637383940package tech.aistar.day01;/** * 本类用来演示: 变量入门 * * @author: success * @date: 2021/7/15 3:43 下午 */public class VarDemo &#123; public static void main(String[] args) &#123; //数据类型 变量名 [= 变量值]; byte b = 10; //代码的背后 - 埋了个&quot;种子&quot;,&quot;发芽&quot; //1. 数据肯定是存储在JVM内存中的 //2. 定义在方法内部的变量 - 局部变量[JVM的栈区] //3. 局部变量的生命周期是伴随着方法(main)的调用的开始和结束 //讲解的本质 //流程 //1. JVM加载VarDemo.class到内存 //2. JVM找到main方法想要去执行里面的程序 //3. 此处需要申请一块区域来保存数据10 // 3-1. 区域的大小由前面的数据类型来决定的 - int类型 - 区域4个字节32bit的大小 // 3-2. 栈里面的区域的大小一旦被确定了,就不能改变 - 肯定有的时候会有内存的浪费 // 3-3. 虽然空间浪费了,但是读取的效率会提高 - 典型的&quot;以空间换时间&quot; //4. 只要是内存中的空间,这个空间必然会有一个地址,所以变量的存在是为了给这个区域取了个名字 // 变量是为了方便用户来通过它访问到这个空间中存储的具体的那个值的 //把整数10赋值给一个int类型的变量a int a = 10; System.out.println(a); // == 比较的就是&quot;坑 - 区域&quot;里面存储的数据 System.out.println(b == a);//true &#125;&#125; 数据类型的转换 常识规定 a. java中看到一个整数,默认就是int类型 b. java中看到一个小数,默认就是double类型 c. 大的数据类型和小的数据类型进行计算的时候,计算得到的结果是偏向类型大的一方. 自动转换 小的数据类型可以自动转换成大的数据类型. byte-&gt;short-&gt;int-&gt;long char-&gt;int int-&gt;double 强制类型转换 大的数据类型转换成小的数据类型的时候,需要进行强制类型转换的操作 123MaxType 变量1 = 值1;MinType 变量2 = (MinType)变量1; 隐式转换 1234567int-&gt;long整数后面添加l/L double-&gt;float小数后面加上f/F 推荐在double后面加上d/D - 提高语义","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"base","slug":"base","permalink":"http://example.com/tags/base/"}]},{"title":"hexo-1","slug":"hexo-1","date":"2021-07-13T07:13:13.000Z","updated":"2021-07-13T07:14:08.020Z","comments":true,"path":"2021/07/13/hexo-1/","link":"","permalink":"http://example.com/2021/07/13/hexo-1/","excerpt":"","text":"hexo+github搭建博客服务器 csdn,简书,有道笔记 - 广告比较多 hexo+github[比较慢,翻墙]/gitee[Git pages服务器 - 维护]/阿里云服务器 安装nodejs 非中文的非特殊字符的目录中[目录中不要出现空格或者带有特殊符号的] D:/node-v14.17.3-win-x64 环境变量的配置 桌面计算机 - 右击 - 属性 - 高级系统设置 - 环境变量(N) 定位到下方的系统变量 定位到变量名 - Path - 编辑 - 新建 D:/node-v14.17.3-win-x64 一定要关闭所有的环境变量配置的窗口 - 确定 打开终端[如果终端已经打开了,关闭 - 重新打开] win[微软图标]+r - 输入cmd - 输入如下指令检测nodejs是否配置成功 12345npm -v6.14.5 出现版本号,则说明配置成功如果出现了不是内部或者外部的命令的同学,请检查自己的nodejs解压缩之后的路径是否成功配置到了path中 简单认识npm npm是javascript的一个**包[前端框架]**管理工具,并且是nodejs平台默认的包管理工具. 通过npm可以安装,共享,分发代码,管理项目依赖关系. 类似于java中的maven或者gradle[强大的项目构建工具以及项目依赖管理工具] npm简单使用修改镜像 为了下载速度变快,修改npm的镜像 1npm config set registry https://registry.npm.taobao.org 验证一下,镜像是否成功修改了 123npm config get registryhttps://registry.npm.taobao.org/ 简单使用 - 不需要操作 下载bootstrap npm install 框架名称 - 默认下载的是最新的版本 1npm install bootstrap@3 Hexo官网 https://hexo.io/zh-cn/docs/ 安装 假设你在D盘根目录下新建了一个文件夹hello-hexo[博客项目的根目录] win+r - 打开终端 通过dos命令进入到hello-hexo目录中 123C:/User/admin&gt;d:D:&gt;cd hello-hexoD:/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录1D:/hello-hexo&gt;hexo init hello-blog 12cd hello-blogD:/hello-hexo/hello-blog&gt;npm install 测试 - 启动博客服务器1D:/hello-hexo/hello-blog&gt;hexo s 关闭服务器 1ctrl+c 打开浏览器输入:localhost:4000 常用主题模板 https://blog.csdn.net/zgd826237710/article/details/99671027 使用git命令来进行克隆,需要提前安装好git,检测git是否安装成功,重新打开终端 1git --version 注册码云账号 推荐用QQ注册一下 本地配置码云账号信息 - 配置文件 - 位置windows的用户主目录下 C:/User/计算机用户名 - 观察是否存在**.gitconfig**文件,添加如下内容 123[user] email = 码云的QQ邮箱 name = 用户名 安装模板 通过cmd进入到hello-blog目录中的themes目录中 12D:/hello-hexo/hello-blog&gt;cd themesD://hello-hexo/hello-blog/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 或者直接从github上直接clone 1git clone https://github.com/cofess/hexo-theme-pure.git 更新主题配置 指定新的主题 hello-blog目录下的_config.yml文件 1theme: hexo-theme-pure 重启服务器hexo s 个人信息hexo-theme-pure/_config.yml文件 12345overriden author: 亲爱的管管 author_title: 高级打字员 author_description: 个人简介。 location: SuZhou, China Markdown语法 语法的编辑器 - https://typora.io/ 文件的后缀是md 1234567891011121314151617181920212223242526272829303132333435常用语法如下:1. 标题的语法:1~6标题 - # 一级标题 ## 二级标题 2. 代码块 - java,js,mysql...​~~~java 敲enter键3. 列表3-1. 无序列表 * 列表名称 有序列表 1. 列表名称4. 高亮显示 `高亮显示内容`5. 加粗字体 **粗体**6. 斜体 *斜体*7. 粗+斜 ***粗斜***8. 段落 &gt; 空格9. 引入外部图片 ![](xx.png)10. 表格 新建博文1D://hello-hexo/hello-blog&gt;hexo n java 效果:hello-blog目录下的source/_ports/自动生成一个java.md文件 重启blog服务器 1D://hello-hexo/hello-blog&gt;hexo s 主题的侧边栏 侧边栏的链接生效 将/hello-blog/themes/hexo-theme-pure/_source/下的除了_data文件夹,其余文件夹 拷贝一份放入到hello-blog目录下的source目录中即可 文章的分类和标签 只需要在文章的.md文件的自动生成的头部添加 1234title: javadate: 2021-07-13 08:44:42categories: javatags: java 博客的语言环境设置 设置中文 hello-blog下的_config.yml文件中 language: zh-CN 图片显示问题 安装插件 - npm install https://gitee.com/guancg/hexo-asset-image.git –save 需要到hello-blog/_config.yml文件中进行配置 1post_asset_folder: true hexo n 机器学习 效果就是除了生成了机器学习.md还有一个机器学习文件夹,那么这篇文章的所有的图片就可以存储在机器学习文件夹中 hexo s 内置搜索的功能 1234# Searchsearch:insight: true # you need to install `hexo-generator-json-content` before using Insight Searchbaidu: false # you need to disable other search engines to use Baidu search 安装内置搜索插件 npm i -S hexo-generator-json-content 评论 不需要本地数据库进行存储的,用的是第三方的. LeanCloud - 官网地址 - https://www.leancloud.cn/ 注册 - 登录 - 控制台 - 创建应用 - 右下设置 - 应用凭证 appId - sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz appKey - 3hn4ijEgSzJeRV4nkmXThmGV 在hexo-theme-pure\\_config.yml文件中配置 12345678910valine: # Valine. https://valine.js.org appid: sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz # your leancloud application appid appkey: 3hn4ijEgSzJeRV4nkmXThmGV# your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style meta: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # Article reading statistic https://valine.js.org/visitor.html #字数统计&amp;阅读时长 npm i -S hexo-wordcount hexo-theme-pure_config.yml文件中配置 1234postCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 附件-优秀插件 显示图片 1npm install https://gitee.com/guancg/hexo-asset-image.git --save 内置搜索 1npm i -S hexo-generator-json-content 字数统计&amp;阅读时长 1npm i -S hexo-wordcount github部署 1npm install hexo-deployer-git --save github注册一下 github.com chrome浏览器 + iguge - https://iguge.app/ 新建的仓库的名称必须是guancgsuccess.github.io 仓库地址 - https://github.com/guancgsuccess/guancgsuccess.github.io.git 安装github部署插件 npm install hexo-deployer-git –save hello-blog/_config.yml文件 1234deploy:type: &#x27;git&#x27;repo: &#x27;https://github.com/guancgsuccess/guancgsuccess.github.io.git&#x27;branch: &#x27;master&#x27; hexo三连操作 1234hexo clhexo ghexo shexo d 浏览器输入 - guancgsuccess.github.io","categories":[{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}]},{"title":"jqxx","slug":"jqxx","date":"2021-07-13T01:38:38.000Z","updated":"2021-07-13T02:08:29.268Z","comments":true,"path":"2021/07/13/jqxx/","link":"","permalink":"http://example.com/2021/07/13/jqxx/","excerpt":"","text":"","categories":[{"name":"jqxx","slug":"jqxx","permalink":"http://example.com/categories/jqxx/"}],"tags":[{"name":"jqxx","slug":"jqxx","permalink":"http://example.com/tags/jqxx/"}]},{"title":"python","slug":"python","date":"2021-07-13T00:56:35.000Z","updated":"2021-07-13T00:56:58.837Z","comments":true,"path":"2021/07/13/python/","link":"","permalink":"http://example.com/2021/07/13/python/","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"java","slug":"java","date":"2021-07-12T08:51:28.000Z","updated":"2021-07-13T00:55:03.422Z","comments":true,"path":"2021/07/12/java/","link":"","permalink":"http://example.com/2021/07/12/java/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-12T06:57:58.738Z","updated":"2021-07-12T06:57:58.738Z","comments":true,"path":"2021/07/12/hello-world/","link":"","permalink":"http://example.com/2021/07/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"},{"name":"jqxx","slug":"jqxx","permalink":"http://example.com/categories/jqxx/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"static","slug":"static","permalink":"http://example.com/tags/static/"},{"name":"Object","slug":"Object","permalink":"http://example.com/tags/Object/"},{"name":"base","slug":"base","permalink":"http://example.com/tags/base/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"},{"name":"jqxx","slug":"jqxx","permalink":"http://example.com/tags/jqxx/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]}